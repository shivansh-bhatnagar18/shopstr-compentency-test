import { verifyDLEQProof_reblind as vt } from "@cashu/crypto/modules/client/NUT12";
import { pointFromHex as F, hashToCurve as at } from "@cashu/crypto/modules/common";
import { hexToBytes as M, bytesToHex as D } from "@noble/curves/abstract/utils";
import { sha256 as yt } from "@noble/hashes/sha256";
import { Buffer as Q } from "buffer";
import { constructProofFromPromise as Mt, serializeProof as V, blindMessage as C } from "@cashu/crypto/modules/client";
import { getSignedProofs as ut } from "@cashu/crypto/modules/client/NUT11";
import { schnorr as Tt } from "@noble/curves/secp256k1";
import { hexToBytes as G, bytesToHex as O, randomBytes as ht } from "@noble/hashes/utils";
import { deriveSecret as Ut, deriveBlindingFactor as Dt } from "@cashu/crypto/modules/client/NUT09";
function Ot(s) {
  return Q.from(s).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function gt(s) {
  return Q.from(s, "base64");
}
function xt(s) {
  const t = JSON.stringify(s);
  return Bt(Q.from(t).toString("base64"));
}
function Ft(s) {
  const t = Q.from(Nt(s), "base64").toString();
  return JSON.parse(t);
}
function Nt(s) {
  return s.replace(/-/g, "+").replace(/_/g, "/").split("=")[0];
}
function Bt(s) {
  return s.replace(/\+/g, "-").replace(/\//g, "_").split("=")[0];
}
function Kt(s) {
  return typeof s == "number" || typeof s == "string";
}
function J(s) {
  const t = [];
  return Y(s, t), new Uint8Array(t);
}
function Y(s, t) {
  if (s === null)
    t.push(246);
  else if (s === void 0)
    t.push(247);
  else if (typeof s == "boolean")
    t.push(s ? 245 : 244);
  else if (typeof s == "number")
    wt(s, t);
  else if (typeof s == "string")
    kt(s, t);
  else if (Array.isArray(s))
    Qt(s, t);
  else if (s instanceof Uint8Array)
    Rt(s, t);
  else if (typeof s == "object")
    Lt(s, t);
  else
    throw new Error("Unsupported type");
}
function wt(s, t) {
  if (s < 24)
    t.push(s);
  else if (s < 256)
    t.push(24, s);
  else if (s < 65536)
    t.push(25, s >> 8, s & 255);
  else if (s < 4294967296)
    t.push(26, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255);
  else
    throw new Error("Unsupported integer size");
}
function Rt(s, t) {
  const e = s.length;
  if (e < 24)
    t.push(64 + e);
  else if (e < 256)
    t.push(88, e);
  else if (e < 65536)
    t.push(89, e >> 8 & 255, e & 255);
  else if (e < 4294967296)
    t.push(
      90,
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255
    );
  else
    throw new Error("Byte string too long to encode");
  for (let n = 0; n < s.length; n++)
    t.push(s[n]);
}
function kt(s, t) {
  const e = new TextEncoder().encode(s), n = e.length;
  if (n < 24)
    t.push(96 + n);
  else if (n < 256)
    t.push(120, n);
  else if (n < 65536)
    t.push(121, n >> 8 & 255, n & 255);
  else if (n < 4294967296)
    t.push(
      122,
      n >> 24 & 255,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255
    );
  else
    throw new Error("String too long to encode");
  for (let r = 0; r < e.length; r++)
    t.push(e[r]);
}
function Qt(s, t) {
  const e = s.length;
  if (e < 24)
    t.push(128 | e);
  else if (e < 256)
    t.push(152, e);
  else if (e < 65536)
    t.push(153, e >> 8, e & 255);
  else
    throw new Error("Unsupported array length");
  for (const n of s)
    Y(n, t);
}
function Lt(s, t) {
  const e = Object.keys(s);
  wt(e.length, t), t[t.length - 1] |= 160;
  for (const n of e)
    kt(n, t), Y(s[n], t);
}
function X(s) {
  const t = new DataView(s.buffer, s.byteOffset, s.byteLength);
  return W(t, 0).value;
}
function W(s, t) {
  if (t >= s.byteLength)
    throw new Error("Unexpected end of data");
  const e = s.getUint8(t++), n = e >> 5, r = e & 31;
  switch (n) {
    case 0:
      return Wt(s, t, r);
    case 1:
      return jt(s, t, r);
    case 2:
      return Ct(s, t, r);
    case 3:
      return Ht(s, t, r);
    case 4:
      return $t(s, t, r);
    case 5:
      return zt(s, t, r);
    case 7:
      return Gt(s, t, r);
    default:
      throw new Error(`Unsupported major type: ${n}`);
  }
}
function B(s, t, e) {
  if (e < 24) return { value: e, offset: t };
  if (e === 24) return { value: s.getUint8(t++), offset: t };
  if (e === 25) {
    const n = s.getUint16(t, !1);
    return t += 2, { value: n, offset: t };
  }
  if (e === 26) {
    const n = s.getUint32(t, !1);
    return t += 4, { value: n, offset: t };
  }
  if (e === 27) {
    const n = s.getUint32(t, !1), r = s.getUint32(t + 4, !1);
    return t += 8, { value: n * 2 ** 32 + r, offset: t };
  }
  throw new Error(`Unsupported length: ${e}`);
}
function Wt(s, t, e) {
  const { value: n, offset: r } = B(s, t, e);
  return { value: n, offset: r };
}
function jt(s, t, e) {
  const { value: n, offset: r } = B(s, t, e);
  return { value: -1 - n, offset: r };
}
function Ct(s, t, e) {
  const { value: n, offset: r } = B(s, t, e);
  if (r + n > s.byteLength)
    throw new Error("Byte string length exceeds data length");
  return { value: new Uint8Array(s.buffer, s.byteOffset + r, n), offset: r + n };
}
function Ht(s, t, e) {
  const { value: n, offset: r } = B(s, t, e);
  if (r + n > s.byteLength)
    throw new Error("String length exceeds data length");
  const o = new Uint8Array(s.buffer, s.byteOffset + r, n);
  return { value: new TextDecoder().decode(o), offset: r + n };
}
function $t(s, t, e) {
  const { value: n, offset: r } = B(s, t, e), o = [];
  let i = r;
  for (let c = 0; c < n; c++) {
    const a = W(s, i);
    o.push(a.value), i = a.offset;
  }
  return { value: o, offset: i };
}
function zt(s, t, e) {
  const { value: n, offset: r } = B(s, t, e), o = {};
  let i = r;
  for (let c = 0; c < n; c++) {
    const a = W(s, i);
    if (!Kt(a.value))
      throw new Error("Invalid key type");
    const h = W(s, a.offset);
    o[a.value] = h.value, i = h.offset;
  }
  return { value: o, offset: i };
}
function Vt(s) {
  const t = (s & 31744) >> 10, e = s & 1023, n = s & 32768 ? -1 : 1;
  return t === 0 ? n * 2 ** -14 * (e / 1024) : t === 31 ? e ? NaN : n * (1 / 0) : n * 2 ** (t - 15) * (1 + e / 1024);
}
function Gt(s, t, e) {
  if (e < 24)
    switch (e) {
      case 20:
        return { value: !1, offset: t };
      case 21:
        return { value: !0, offset: t };
      case 22:
        return { value: null, offset: t };
      case 23:
        return { value: void 0, offset: t };
      default:
        throw new Error(`Unknown simple value: ${e}`);
    }
  if (e === 24) return { value: s.getUint8(t++), offset: t };
  if (e === 25) {
    const n = Vt(s.getUint16(t, !1));
    return t += 2, { value: n, offset: t };
  }
  if (e === 26) {
    const n = s.getFloat32(t, !1);
    return t += 4, { value: n, offset: t };
  }
  if (e === 27) {
    const n = s.getFloat64(t, !1);
    return t += 8, { value: n, offset: t };
  }
  throw new Error(`Unknown simple or float value: ${e}`);
}
class Z {
  constructor(t, e, n, r, o, i, c = !1) {
    this.transport = t, this.id = e, this.amount = n, this.unit = r, this.mints = o, this.description = i, this.singleUse = c;
  }
  toRawRequest() {
    const t = {
      t: this.transport.map((e) => ({ t: e.type, a: e.target, g: e.tags }))
    };
    return this.id && (t.i = this.id), this.amount && (t.a = this.amount), this.unit && (t.u = this.unit), this.mints && (t.m = this.mints), this.description && (t.d = this.description), this.singleUse && (t.s = this.singleUse), t;
  }
  toEncodedRequest() {
    const t = this.toRawRequest(), e = J(t);
    return "creqA" + Q.from(e).toString("base64");
  }
  getTransport(t) {
    return this.transport.find((e) => e.type === t);
  }
  static fromRawRequest(t) {
    const e = t.t.map((n) => ({
      type: n.t,
      target: n.a,
      tags: n.g
    }));
    return new Z(
      e,
      t.i,
      t.a,
      t.u,
      t.m,
      t.d,
      t.s
    );
  }
  static fromEncodedRequest(t) {
    if (!t.startsWith("creq"))
      throw new Error("unsupported pr: invalid prefix");
    if (t[4] !== "A")
      throw new Error("unsupported pr version");
    const n = t.slice(5), r = gt(n), o = X(r);
    return this.fromRawRequest(o);
  }
}
const Jt = "A", Yt = "cashu";
function S(s, t, e, n) {
  if (e) {
    const o = ft(e);
    if (o > s)
      throw new Error(`Split is greater than total amount: ${o} > ${s}`);
    if (e.some((i) => !_t(i, t)))
      throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");
    s = s - ft(e);
  } else
    e = [];
  return bt(t, "desc").forEach((o) => {
    const i = Math.floor(s / o);
    for (let c = 0; c < i; ++c) e?.push(o);
    s %= o;
  }), e.sort((o, i) => o - i);
}
function dt(s, t, e, n) {
  const r = [], o = s.map((h) => h.amount);
  bt(e, "asc").forEach((h) => {
    const d = o.filter((m) => m === h).length, f = Math.max(n - d, 0);
    for (let m = 0; m < f && !(r.reduce((u, l) => u + l, 0) + h > t); ++m)
      r.push(h);
  });
  const c = t - r.reduce((h, d) => h + d, 0);
  return c && S(c, e).forEach((d) => {
    r.push(d);
  }), r.sort((h, d) => h - d);
}
function bt(s, t = "desc") {
  return t == "desc" ? Object.keys(s).map((e) => parseInt(e)).sort((e, n) => n - e) : Object.keys(s).map((e) => parseInt(e)).sort((e, n) => e - n);
}
function _t(s, t) {
  return s in t;
}
function Xt(s) {
  return Et(D(s));
}
function Et(s) {
  return BigInt(`0x${s}`);
}
function Zt(s) {
  return s.toString(16).padStart(64, "0");
}
function lt(s) {
  return /^[a-f0-9]*$/i.test(s);
}
function Pt(s) {
  return Array.isArray(s) ? s.some((t) => !lt(t.id)) : lt(s.id);
}
function te(s) {
  const t = { token: [{ mint: s.mint, proofs: s.proofs }] };
  return s.unit && (t.unit = s.unit), s.memo && (t.memo = s.memo), Yt + Jt + xt(t);
}
function Te(s, t) {
  if (Pt(s.proofs) || t?.version === 3) {
    if (t?.version === 4)
      throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
    return te(s);
  }
  return ee(s);
}
function ee(s) {
  if (s.proofs.forEach((c) => {
    if (c.dleq && c.dleq.r == null)
      throw new Error("Missing blinding factor in included DLEQ proof");
  }), Pt(s.proofs))
    throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
  const e = St(s), n = J(e), r = "cashu", o = "B", i = Ot(n);
  return r + o + i;
}
function St(s) {
  const t = {}, e = s.mint;
  for (let r = 0; r < s.proofs.length; r++) {
    const o = s.proofs[r];
    t[o.id] ? t[o.id].push(o) : t[o.id] = [o];
  }
  const n = {
    m: e,
    u: s.unit || "sat",
    t: Object.keys(t).map(
      (r) => ({
        i: M(r),
        p: t[r].map(
          (o) => ({
            a: o.amount,
            s: o.secret,
            c: M(o.C),
            ...o.dleq && {
              d: {
                e: M(o.dleq.e),
                s: M(o.dleq.s),
                r: M(o.dleq.r ?? "00")
              }
            }
          })
        )
      })
    )
  };
  return s.memo && (n.d = s.memo), n;
}
function It(s) {
  const t = [];
  s.t.forEach(
    (n) => n.p.forEach((r) => {
      t.push({
        secret: r.s,
        C: D(r.c),
        amount: r.a,
        id: D(n.i),
        ...r.d && {
          dleq: {
            r: D(r.d.r),
            s: D(r.d.s),
            e: D(r.d.e)
          }
        }
      });
    })
  );
  const e = { mint: s.m, proofs: t, unit: s.u || "sat" };
  return s.d && (e.memo = s.d), e;
}
function se(s) {
  return ["web+cashu://", "cashu://", "cashu:", "cashu"].forEach((e) => {
    s.startsWith(e) && (s = s.slice(e.length));
  }), ne(s);
}
function ne(s) {
  const t = s.slice(0, 1), e = s.slice(1);
  if (t === "A") {
    const n = Ft(e);
    if (n.token.length > 1)
      throw new Error("Multi entry token are not supported");
    const r = n.token[0], o = {
      mint: r.mint,
      proofs: r.proofs,
      unit: n.unit || "sat"
    };
    return n.memo && (o.memo = n.memo), o;
  } else if (t === "B") {
    const n = gt(e), r = X(n);
    return It(r);
  }
  throw new Error("Token version is not supported");
}
function Ue(s) {
  const t = Object.entries(s).sort((r, o) => +r[0] - +o[0]).map(([, r]) => M(r)).reduce((r, o) => re(r, o), new Uint8Array()), e = yt(t);
  return "00" + Buffer.from(e).toString("hex").slice(0, 14);
}
function re(s, t) {
  const e = new Uint8Array(s.length + t.length);
  return e.set(s), e.set(t, s.length), e;
}
function v(s) {
  return typeof s == "object";
}
function E(...s) {
  return s.map((t) => t.replace(/(^\/+|\/+$)/g, "")).join("/");
}
function oe(s) {
  return s.replace(/\/$/, "");
}
function U(s) {
  return s.reduce((t, e) => t + e.amount, 0);
}
function De(s) {
  return Z.fromEncodedRequest(s);
}
class ie {
  get value() {
    return this._value;
  }
  set value(t) {
    this._value = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  constructor(t) {
    this._value = t, this._next = null;
  }
}
class ce {
  get first() {
    return this._first;
  }
  set first(t) {
    this._first = t;
  }
  get last() {
    return this._last;
  }
  set last(t) {
    this._last = t;
  }
  get size() {
    return this._size;
  }
  set size(t) {
    this._size = t;
  }
  constructor() {
    this._first = null, this._last = null, this._size = 0;
  }
  enqueue(t) {
    const e = new ie(t);
    return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, !0;
  }
  dequeue() {
    if (this._size === 0 || !this._first) return null;
    const t = this._first;
    return this._first = t.next, t.next = null, this._size--, t.value;
  }
}
function L(s) {
  return s.map((t) => {
    const e = { ...t };
    return delete e.dleq, e;
  });
}
function ae(s, t) {
  if (s.dleq == null)
    return !1;
  const e = {
    e: M(s.dleq.e),
    s: M(s.dleq.s),
    r: Et(s.dleq.r ?? "00")
  };
  if (!_t(s.amount, t.keys))
    throw new Error(`undefined key for amount ${s.amount}`);
  const n = t.keys[s.amount];
  return !!vt(
    new TextEncoder().encode(s.secret),
    e,
    F(s.C),
    F(n)
  );
}
function ue(...s) {
  const t = s.reduce((r, o) => r + o.length, 0), e = new Uint8Array(t);
  let n = 0;
  for (let r = 0; r < s.length; r++)
    e.set(s[r], n), n = n + s[r].length;
  return e;
}
function Oe(s) {
  const t = new TextEncoder(), e = St(s), n = J(e), r = t.encode("craw"), o = t.encode("B");
  return ue(r, o, n);
}
function xe(s) {
  const t = new TextDecoder(), e = t.decode(s.slice(0, 4)), n = t.decode(new Uint8Array([s[4]]));
  if (e !== "craw" || n !== "B")
    throw new Error("not a valid binary token");
  const r = s.slice(5), o = X(r);
  return It(o);
}
function ft(s) {
  return s.reduce((t, e) => t + e, 0);
}
let tt;
typeof WebSocket < "u" && (tt = WebSocket);
function Fe(s) {
  tt = s;
}
function he() {
  return tt;
}
class x {
  constructor() {
    this.connectionMap = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return x.instace || (x.instace = new x()), x.instace;
  }
  getConnection(t) {
    if (this.connectionMap.has(t))
      return this.connectionMap.get(t);
    const e = new de(t);
    return this.connectionMap.set(t, e), e;
  }
}
class de {
  constructor(t) {
    this.subListeners = {}, this.rpcListeners = {}, this.rpcId = 0, this._WS = he(), this.url = new URL(t), this.messageQueue = new ce();
  }
  connect() {
    return this.connectionPromise || (this.connectionPromise = new Promise((t, e) => {
      try {
        this.ws = new this._WS(this.url);
      } catch (n) {
        e(n);
        return;
      }
      this.ws.onopen = () => {
        t();
      }, this.ws.onerror = () => {
        e(new Error("Failed to open WebSocket"));
      }, this.ws.onmessage = (n) => {
        this.messageQueue.enqueue(n.data), this.handlingInterval || (this.handlingInterval = setInterval(
          this.handleNextMesage.bind(this),
          0
        ));
      }, this.ws.onclose = () => {
        this.connectionPromise = void 0;
      };
    })), this.connectionPromise;
  }
  sendRequest(t, e) {
    if (this.ws?.readyState !== 1)
      throw new Error("Socket not open...");
    const n = this.rpcId;
    this.rpcId++;
    const r = JSON.stringify({ jsonrpc: "2.0", method: t, params: e, id: n });
    this.ws?.send(r);
  }
  closeSubscription(t) {
    this.ws?.send(JSON.stringify(["CLOSE", t]));
  }
  addSubListener(t, e) {
    (this.subListeners[t] = this.subListeners[t] || []).push(e);
  }
  //TODO: Move to RPCManagerClass
  addRpcListener(t, e, n) {
    this.rpcListeners[n] = { callback: t, errorCallback: e };
  }
  //TODO: Move to RPCManagerClass
  removeRpcListener(t) {
    delete this.rpcListeners[t];
  }
  removeListener(t, e) {
    if (this.subListeners[t].length === 1) {
      delete this.subListeners[t];
      return;
    }
    this.subListeners[t] = this.subListeners[t].filter((n) => n !== e);
  }
  async ensureConnection() {
    this.ws?.readyState !== 1 && await this.connect();
  }
  handleNextMesage() {
    if (this.messageQueue.size === 0) {
      clearInterval(this.handlingInterval), this.handlingInterval = void 0;
      return;
    }
    const t = this.messageQueue.dequeue();
    let e;
    try {
      if (e = JSON.parse(t), "result" in e && e.id != null)
        this.rpcListeners[e.id] && (this.rpcListeners[e.id].callback(), this.removeRpcListener(e.id));
      else if ("error" in e && e.id != null)
        this.rpcListeners[e.id] && (this.rpcListeners[e.id].errorCallback(e.error), this.removeRpcListener(e.id));
      else if ("method" in e && !("id" in e)) {
        const n = e.params.subId;
        if (!n)
          return;
        if (this.subListeners[n]?.length > 0) {
          const r = e;
          this.subListeners[n].forEach((o) => o(r.params.payload));
        }
      }
    } catch (n) {
      console.error(n);
      return;
    }
  }
  createSubscription(t, e, n) {
    if (this.ws?.readyState !== 1)
      return n(new Error("Socket is not open"));
    const r = (Math.random() + 1).toString(36).substring(7);
    return this.addRpcListener(
      () => {
        this.addSubListener(r, e);
      },
      (o) => {
        n(new Error(o.message));
      },
      this.rpcId
    ), this.sendRequest("subscribe", { ...t, subId: r }), this.rpcId++, r;
  }
  cancelSubscription(t, e) {
    this.removeListener(t, e), this.rpcId++, this.sendRequest("unsubscribe", { subId: t });
  }
  get activeSubscriptions() {
    return Object.keys(this.subListeners);
  }
  close() {
    this.ws && this.ws?.close();
  }
}
var le = /* @__PURE__ */ ((s) => (s.UNSPENT = "UNSPENT", s.PENDING = "PENDING", s.SPENT = "SPENT", s))(le || {}), N = /* @__PURE__ */ ((s) => (s.UNPAID = "UNPAID", s.PENDING = "PENDING", s.PAID = "PAID", s))(N || {}), j = /* @__PURE__ */ ((s) => (s.UNPAID = "UNPAID", s.PAID = "PAID", s.ISSUED = "ISSUED", s))(j || {}), fe = /* @__PURE__ */ ((s) => (s.POST = "post", s.NOSTR = "nostr", s))(fe || {});
class R extends Error {
  constructor(t, e) {
    super(t), this.status = e, this.name = "HttpResponseError", Object.setPrototypeOf(this, R.prototype);
  }
}
class et extends Error {
  constructor(t) {
    super(t), this.name = "NetworkError", Object.setPrototypeOf(this, et.prototype);
  }
}
class st extends R {
  constructor(t, e) {
    super(e || "Unknown mint operation error", 400), this.code = t, this.name = "MintOperationError", Object.setPrototypeOf(this, st.prototype);
  }
}
let At = {};
function Ne(s) {
  At = s;
}
async function pe({
  endpoint: s,
  requestBody: t,
  headers: e,
  ...n
}) {
  const r = t ? JSON.stringify(t) : void 0, o = {
    Accept: "application/json, text/plain, */*",
    ...r ? { "Content-Type": "application/json" } : void 0,
    ...e
  };
  let i;
  try {
    i = await fetch(s, { body: r, headers: o, ...n });
  } catch (c) {
    throw new et(c instanceof Error ? c.message : "Network request failed");
  }
  if (!i.ok) {
    const c = await i.json().catch(() => ({ error: "bad response" }));
    throw i.status === 400 && "code" in c && "detail" in c ? new st(c.code, c.detail) : new R(
      "error" in c ? c.error : c.detail || "HTTP request failed",
      i.status
    );
  }
  try {
    return await i.json();
  } catch (c) {
    throw console.error("Failed to parse HTTP response", c), new R("bad response", i.status);
  }
}
async function A(s) {
  return await pe({ ...s, ...At });
}
function H(s) {
  return s.state || (console.warn(
    "Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"
  ), typeof s.paid == "boolean" && (s.state = s.paid ? N.PAID : N.UNPAID)), s;
}
function pt(s) {
  return s.state || (console.warn(
    "Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"
  ), typeof s.paid == "boolean" && (s.state = s.paid ? j.PAID : j.UNPAID)), s;
}
function me(s) {
  return Array.isArray(s?.contact) && s?.contact.length > 0 && (s.contact = s.contact.map((t) => Array.isArray(t) && t.length === 2 && typeof t[0] == "string" && typeof t[1] == "string" ? (console.warn(
    "Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"
  ), { method: t[0], info: t[1] }) : t)), s;
}
class P {
  /**
   * @param _mintUrl requires mint URL to create this object
   * @param _customRequest if passed, use custom request implementation for network communication with the mint
   */
  constructor(t, e) {
    this._mintUrl = t, this._customRequest = e, this._mintUrl = oe(t), this._customRequest = e;
  }
  get mintUrl() {
    return this._mintUrl;
  }
  /**
   * fetches mints info at the /info endpoint
   * @param mintUrl
   * @param customRequest
   */
  static async getInfo(t, e) {
    const r = await (e || A)({
      endpoint: E(t, "/v1/info")
    });
    return me(r);
  }
  /**
   * fetches mints info at the /info endpoint
   */
  async getInfo() {
    return P.getInfo(this._mintUrl, this._customRequest);
  }
  /**
   * Performs a swap operation with ecash inputs and outputs.
   * @param mintUrl
   * @param swapPayload payload containing inputs and outputs
   * @param customRequest
   * @returns signed outputs
   */
  static async swap(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/swap"),
      method: "POST",
      requestBody: e
    });
    if (!v(o) || !Array.isArray(o?.signatures))
      throw new Error(o.detail ?? "bad response");
    return o;
  }
  /**
   * Performs a swap operation with ecash inputs and outputs.
   * @param swapPayload payload containing inputs and outputs
   * @returns signed outputs
   */
  async swap(t) {
    return P.swap(this._mintUrl, t, this._customRequest);
  }
  /**
   * Requests a new mint quote from the mint.
   * @param mintUrl
   * @param mintQuotePayload Payload for creating a new mint quote
   * @param customRequest
   * @returns the mint will create and return a new mint quote containing a payment request for the specified amount and unit
   */
  static async createMintQuote(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/mint/quote/bolt11"),
      method: "POST",
      requestBody: e
    });
    return pt(o);
  }
  /**
   * Requests a new mint quote from the mint.
   * @param mintQuotePayload Payload for creating a new mint quote
   * @returns the mint will create and return a new mint quote containing a payment request for the specified amount and unit
   */
  async createMintQuote(t) {
    return P.createMintQuote(this._mintUrl, t, this._customRequest);
  }
  /**
   * Gets an existing mint quote from the mint.
   * @param mintUrl
   * @param quote Quote ID
   * @param customRequest
   * @returns the mint will create and return a Lightning invoice for the specified amount
   */
  static async checkMintQuote(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/mint/quote/bolt11", e),
      method: "GET"
    });
    return pt(o);
  }
  /**
   * Gets an existing mint quote from the mint.
   * @param quote Quote ID
   * @returns the mint will create and return a Lightning invoice for the specified amount
   */
  async checkMintQuote(t) {
    return P.checkMintQuote(this._mintUrl, t, this._customRequest);
  }
  /**
   * Mints new tokens by requesting blind signatures on the provided outputs.
   * @param mintUrl
   * @param mintPayload Payload containing the outputs to get blind signatures on
   * @param customRequest
   * @returns serialized blinded signatures
   */
  static async mint(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/mint/bolt11"),
      method: "POST",
      requestBody: e
    });
    if (!v(o) || !Array.isArray(o?.signatures))
      throw new Error("bad response");
    return o;
  }
  /**
   * Mints new tokens by requesting blind signatures on the provided outputs.
   * @param mintPayload Payload containing the outputs to get blind signatures on
   * @returns serialized blinded signatures
   */
  async mint(t) {
    return P.mint(this._mintUrl, t, this._customRequest);
  }
  /**
   * Requests a new melt quote from the mint.
   * @param mintUrl
   * @param MeltQuotePayload
   * @returns
   */
  static async createMeltQuote(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/melt/quote/bolt11"),
      method: "POST",
      requestBody: e
    }), i = H(o);
    if (!v(i) || typeof i?.amount != "number" || typeof i?.fee_reserve != "number" || typeof i?.quote != "string")
      throw new Error("bad response");
    return i;
  }
  /**
   * Requests a new melt quote from the mint.
   * @param MeltQuotePayload
   * @returns
   */
  async createMeltQuote(t) {
    return P.createMeltQuote(this._mintUrl, t, this._customRequest);
  }
  /**
   * Gets an existing melt quote.
   * @param mintUrl
   * @param quote Quote ID
   * @returns
   */
  static async checkMeltQuote(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/melt/quote/bolt11", e),
      method: "GET"
    }), i = H(o);
    if (!v(i) || typeof i?.amount != "number" || typeof i?.fee_reserve != "number" || typeof i?.quote != "string" || typeof i?.state != "string" || !Object.values(N).includes(i.state))
      throw new Error("bad response");
    return i;
  }
  /**
   * Gets an existing melt quote.
   * @param quote Quote ID
   * @returns
   */
  async checkMeltQuote(t) {
    return P.checkMeltQuote(this._mintUrl, t, this._customRequest);
  }
  /**
   * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent. The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can also contain blank outputs in order to receive back overpaid Lightning fees.
   * @param mintUrl
   * @param meltPayload
   * @param customRequest
   * @returns
   */
  static async melt(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/melt/bolt11"),
      method: "POST",
      requestBody: e
    }), i = H(o);
    if (!v(i) || typeof i?.state != "string" || !Object.values(N).includes(i.state))
      throw new Error("bad response");
    return i;
  }
  /**
   * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens matching its amount + fees
   * @param meltPayload
   * @returns
   */
  async melt(t) {
    return P.melt(this._mintUrl, t, this._customRequest);
  }
  /**
   * Checks if specific proofs have already been redeemed
   * @param mintUrl
   * @param checkPayload
   * @param customRequest
   * @returns redeemed and unredeemed ordered list of booleans
   */
  static async check(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/checkstate"),
      method: "POST",
      requestBody: e
    });
    if (!v(o) || !Array.isArray(o?.states))
      throw new Error("bad response");
    return o;
  }
  /**
   * Get the mints public keys
   * @param mintUrl
   * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched
   * @param customRequest
   * @returns
   */
  static async getKeys(t, e, n) {
    e && (e = e.replace(/\//g, "_").replace(/\+/g, "-"));
    const o = await (n || A)({
      endpoint: e ? E(t, "/v1/keys", e) : E(t, "/v1/keys")
    });
    if (!v(o) || !Array.isArray(o.keysets))
      throw new Error("bad response");
    return o;
  }
  /**
   * Get the mints public keys
   * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched
   * @returns the mints public keys
   */
  async getKeys(t, e) {
    return await P.getKeys(
      e || this._mintUrl,
      t,
      this._customRequest
    );
  }
  /**
   * Get the mints keysets in no specific order
   * @param mintUrl
   * @param customRequest
   * @returns all the mints past and current keysets.
   */
  static async getKeySets(t, e) {
    return (e || A)({ endpoint: E(t, "/v1/keysets") });
  }
  /**
   * Get the mints keysets in no specific order
   * @returns all the mints past and current keysets.
   */
  async getKeySets() {
    return P.getKeySets(this._mintUrl, this._customRequest);
  }
  /**
   * Checks if specific proofs have already been redeemed
   * @param checkPayload
   * @returns redeemed and unredeemed ordered list of booleans
   */
  async check(t) {
    return P.check(this._mintUrl, t, this._customRequest);
  }
  static async restore(t, e, n) {
    const o = await (n || A)({
      endpoint: E(t, "/v1/restore"),
      method: "POST",
      requestBody: e
    });
    if (!v(o) || !Array.isArray(o?.outputs) || !Array.isArray(o?.signatures))
      throw new Error("bad response");
    return o;
  }
  async restore(t) {
    return P.restore(this._mintUrl, t, this._customRequest);
  }
  /**
   * Tries to establish a websocket connection with the websocket mint url according to NUT-17
   */
  async connectWebSocket() {
    if (this.ws)
      await this.ws.ensureConnection();
    else {
      const t = new URL(this._mintUrl), e = "v1/ws";
      t.pathname && (t.pathname.endsWith("/") ? t.pathname += e : t.pathname += "/" + e), this.ws = x.getInstance().getConnection(
        `${t.protocol === "https:" ? "wss" : "ws"}://${t.host}${t.pathname}`
      );
      try {
        await this.ws.connect();
      } catch (n) {
        throw console.log(n), new Error("Failed to connect to WebSocket...");
      }
    }
  }
  /**
   * Closes a websocket connection
   */
  disconnectWebSocket() {
    this.ws && this.ws.close();
  }
  get webSocketConnection() {
    return this.ws;
  }
}
class mt {
  constructor(t) {
    this._mintInfo = t;
  }
  isSupported(t) {
    switch (t) {
      case 4:
      case 5:
        return this.checkMintMelt(t);
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 14:
      case 20:
        return this.checkGenericNut(t);
      case 17:
        return this.checkNut17();
      case 15:
        return this.checkNut15();
      default:
        throw new Error("nut is not supported by cashu-ts");
    }
  }
  checkGenericNut(t) {
    return this._mintInfo.nuts[t]?.supported ? { supported: !0 } : { supported: !1 };
  }
  checkMintMelt(t) {
    const e = this._mintInfo.nuts[t];
    return e && e.methods.length > 0 && !e.disabled ? { disabled: !1, params: e.methods } : { disabled: !0, params: e.methods };
  }
  checkNut17() {
    return this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0 ? { supported: !0, params: this._mintInfo.nuts[17].supported } : { supported: !1 };
  }
  checkNut15() {
    return this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0 ? { supported: !0, params: this._mintInfo.nuts[15].methods } : { supported: !1 };
  }
  get contact() {
    return this._mintInfo.contact;
  }
  get description() {
    return this._mintInfo.description;
  }
  get description_long() {
    return this._mintInfo.description_long;
  }
  get name() {
    return this._mintInfo.name;
  }
  get pubkey() {
    return this._mintInfo.pubkey;
  }
  get nuts() {
    return this._mintInfo.nuts;
  }
  get version() {
    return this._mintInfo.version;
  }
  get motd() {
    return this._mintInfo.motd;
  }
}
function ye(s, t) {
  let e = s;
  for (const r of t)
    e += r.B_;
  const n = new TextEncoder().encode(e);
  return yt(n);
}
function ge(s, t, e) {
  const n = ye(t, e), r = G(s), o = Tt.sign(n, r);
  return O(o);
}
class $ {
  constructor(t, e, n) {
    this.amount = t, this.B_ = e, this.id = n;
  }
  getSerializedBlindedMessage() {
    return { amount: this.amount, B_: this.B_.toHex(!0), id: this.id };
  }
}
function z(s) {
  return typeof s == "function";
}
class q {
  constructor(t, e, n) {
    this.secret = n, this.blindingFactor = e, this.blindedMessage = t;
  }
  toProof(t, e) {
    let n;
    t.dleq && (n = {
      s: G(t.dleq.s),
      e: G(t.dleq.e),
      r: this.blindingFactor
    });
    const r = {
      id: t.id,
      amount: t.amount,
      C_: F(t.C_),
      dleq: n
    }, o = F(e.keys[t.amount]), i = Mt(r, this.blindingFactor, this.secret, o);
    return {
      ...V(i),
      ...n && {
        dleq: {
          s: O(n.s),
          e: O(n.e),
          r: Zt(n.r ?? BigInt(0))
        }
      }
    };
  }
  static createP2PKData(t, e, n, r) {
    return S(e, n.keys, r).map((i) => this.createSingleP2PKData(t, i, n.id));
  }
  static createSingleP2PKData(t, e, n) {
    const r = [
      "P2PK",
      {
        nonce: O(ht(32)),
        data: t.pubkey,
        tags: []
      }
    ];
    t.locktime && r[1].tags.push(["locktime", t.locktime]), t.refundKeys && r[1].tags.push(["refund", t.refundKeys]);
    const o = JSON.stringify(r), i = new TextEncoder().encode(o), { r: c, B_: a } = C(i);
    return new q(
      new $(e, a, n).getSerializedBlindedMessage(),
      c,
      i
    );
  }
  static createRandomData(t, e, n) {
    return S(t, e.keys, n).map((o) => this.createSingleRandomData(o, e.id));
  }
  static createSingleRandomData(t, e) {
    const n = O(ht(32)), r = new TextEncoder().encode(n), { r: o, B_: i } = C(r);
    return new q(
      new $(t, i, e).getSerializedBlindedMessage(),
      o,
      r
    );
  }
  static createDeterministicData(t, e, n, r, o) {
    return S(t, r.keys, o).map(
      (c, a) => this.createSingleDeterministicData(c, e, n + a, r.id)
    );
  }
  static createSingleDeterministicData(t, e, n, r) {
    const o = Ut(e, r, n), i = O(o), c = new TextEncoder().encode(i), a = Xt(Dt(e, r, n)), { r: h, B_: d } = C(c, a);
    return new q(
      new $(t, d, r).getSerializedBlindedMessage(),
      h,
      c
    );
  }
}
const we = 3, ke = "sat";
class Be {
  /**
   * @param mint Cashu mint instance is used to make api calls
   * @param options.unit optionally set unit (default is 'sat')
   * @param options.keys public keys from the mint (will be fetched from mint if not provided)
   * @param options.keysets keysets from the mint (will be fetched from mint if not provided)
   * @param options.mintInfo mint info from the mint (will be fetched from mint if not provided)
   * @param options.denominationTarget target number proofs per denomination (default: see @constant DEFAULT_DENOMINATION_TARGET)
   * @param options.bip39seed BIP39 seed for deterministic secrets.
   * @param options.keepFactory A function that will be used by all parts of the library that produce proofs to be kept (change, etc.).
   * This can lead to poor performance, in which case the seed should be directly provided
   */
  constructor(t, e) {
    this._keys = /* @__PURE__ */ new Map(), this._keysets = [], this._seed = void 0, this._unit = ke, this._mintInfo = void 0, this._denominationTarget = we, this.mint = t;
    let n = [];
    if (e?.keys && !Array.isArray(e.keys) ? n = [e.keys] : e?.keys && Array.isArray(e?.keys) && (n = e?.keys), n && n.forEach((r) => this._keys.set(r.id, r)), e?.unit && (this._unit = e?.unit), e?.keysets && (this._keysets = e.keysets), e?.mintInfo && (this._mintInfo = new mt(e.mintInfo)), e?.denominationTarget && (this._denominationTarget = e.denominationTarget), e?.bip39seed) {
      if (e.bip39seed instanceof Uint8Array) {
        this._seed = e.bip39seed;
        return;
      }
      throw new Error("bip39seed must be a valid UInt8Array");
    }
    e?.keepFactory && (this._keepFactory = e.keepFactory);
  }
  get unit() {
    return this._unit;
  }
  get keys() {
    return this._keys;
  }
  get keysetId() {
    if (!this._keysetId)
      throw new Error("No keysetId set");
    return this._keysetId;
  }
  set keysetId(t) {
    this._keysetId = t;
  }
  get keysets() {
    return this._keysets;
  }
  get mintInfo() {
    if (!this._mintInfo)
      throw new Error("Mint info not loaded");
    return this._mintInfo;
  }
  /**
   * Get information about the mint
   * @returns mint info
   */
  async getMintInfo() {
    const t = await this.mint.getInfo();
    return this._mintInfo = new mt(t), this._mintInfo;
  }
  /**
   * Get stored information about the mint or request it if not loaded.
   * @returns mint info
   */
  async lazyGetMintInfo() {
    return this._mintInfo ? this._mintInfo : await this.getMintInfo();
  }
  /**
   * Load mint information, keysets and keys. This function can be called if no keysets are passed in the constructor
   */
  async loadMint() {
    await this.getMintInfo(), await this.getKeySets(), await this.getKeys();
  }
  /**
   * Choose a keyset to activate based on the lowest input fee
   *
   * Note: this function will filter out deprecated base64 keysets
   *
   * @param keysets keysets to choose from
   * @returns active keyset
   */
  getActiveKeyset(t) {
    let e = t.filter((r) => r.active);
    e = e.filter((r) => r.id.startsWith("00"));
    const n = e.sort(
      (r, o) => (r.input_fee_ppk ?? 0) - (o.input_fee_ppk ?? 0)
    )[0];
    if (!n)
      throw new Error("No active keyset found");
    return n;
  }
  /**
   * Get keysets from the mint with the unit of the wallet
   * @returns keysets with wallet's unit
   */
  async getKeySets() {
    const e = (await this.mint.getKeySets()).keysets.filter((n) => n.unit === this._unit);
    return this._keysets = e, this._keysets;
  }
  /**
   * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet keyset.
   * @returns keyset
   */
  async getAllKeys() {
    const t = await this.mint.getKeys();
    return this._keys = new Map(t.keysets.map((e) => [e.id, e])), this.keysetId = this.getActiveKeyset(this._keysets).id, t.keysets;
  }
  /**
   * Get public keys from the mint. If keys were already fetched, it will return those.
   *
   * If `keysetId` is set, it will fetch and return that specific keyset.
   * Otherwise, we select an active keyset with the unit of the wallet.
   *
   * @param keysetId optional keysetId to get keys for
   * @param forceRefresh? if set to true, it will force refresh the keyset from the mint
   * @returns keyset
   */
  async getKeys(t, e) {
    if ((!(this._keysets.length > 0) || e) && await this.getKeySets(), t || (t = this.getActiveKeyset(this._keysets).id), !this._keysets.find((n) => n.id === t) && (await this.getKeySets(), !this._keysets.find((n) => n.id === t)))
      throw new Error(`could not initialize keys. No keyset with id '${t}' found`);
    if (!this._keys.get(t)) {
      const n = await this.mint.getKeys(t);
      this._keys.set(t, n.keysets[0]);
    }
    return this.keysetId = t, this._keys.get(t);
  }
  /**
   * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the first token in the token array)
   * @param {(string|Token)} token - Cashu token, either as string or decoded
   * @param {ReceiveOptions} [options] - Optional configuration for token processing
   * @returns New token with newly created proofs, token entries that had errors
   */
  async receive(t, e) {
    const { requireDleq: n, keysetId: r, outputAmounts: o, counter: i, pubkey: c, privkey: a, outputData: h, p2pk: d } = e || {};
    typeof t == "string" && (t = se(t));
    const f = await this.getKeys(r);
    if (n && t.proofs.some((k) => !ae(k, f)))
      throw new Error("Token contains proofs with invalid DLEQ");
    const m = U(t.proofs) - this.getFeesForProofs(t.proofs);
    let u;
    h ? u = { send: h } : this._keepFactory && (u = { send: this._keepFactory });
    const l = this.createSwapPayload(
      m,
      t.proofs,
      f,
      o,
      i,
      c,
      a,
      u,
      d
    ), { signatures: w } = await this.mint.swap(l.payload), y = l.outputData.map((k, p) => k.toProof(w[p], f)), g = [];
    return l.sortedIndices.forEach((k, p) => {
      g[k] = y[p];
    }), g;
  }
  /**
   * Send proofs of a given amount, by providing at least the required amount of proofs
   * @param amount amount to send
   * @param proofs array of proofs (accumulated amount of proofs must be >= than amount)
   * @param {SendOptions} [options] - Optional parameters for configuring the send operation
   * @returns {SendResponse}
   */
  async send(t, e, n) {
    const {
      proofsWeHave: r,
      offline: o,
      includeFees: i,
      includeDleq: c,
      keysetId: a,
      outputAmounts: h,
      pubkey: d,
      privkey: f,
      outputData: m
    } = n || {};
    if (c && (e = e.filter((y) => y.dleq != null)), U(e) < t)
      throw new Error("Not enough funds available to send");
    const { keep: u, send: l } = this.selectProofsToSend(
      e,
      t,
      n?.includeFees
    ), w = i ? this.getFeesForProofs(l) : 0;
    if (!o && (U(l) != t + w || // if the exact amount cannot be selected
    h || d || f || a || m)) {
      const { keep: y, send: g } = this.selectProofsToSend(
        e,
        t,
        !0
      );
      r?.push(...y);
      const k = await this.swap(t, g, n);
      let { keep: p, send: _ } = k;
      const T = k.serialized;
      return p = y.concat(p), c || (_ = L(_)), { keep: p, send: _, serialized: T };
    }
    if (U(l) < t + w)
      throw new Error("Not enough funds available to send");
    return c ? { keep: u, send: l } : { keep: u, send: L(l) };
  }
  selectProofsToSend(t, e, n) {
    const r = t.sort((u, l) => u.amount - l.amount), o = r.filter((u) => u.amount <= e).sort((u, l) => l.amount - u.amount), c = r.filter((u) => u.amount > e).sort((u, l) => u.amount - l.amount)[0];
    if (!o.length && c)
      return {
        keep: t.filter((u) => u.secret !== c.secret),
        send: [c]
      };
    if (!o.length && !c)
      return { keep: t, send: [] };
    let a = e, h = [o[0]];
    const d = [], f = n ? this.getFeesForProofs(h) : 0;
    if (a -= h[0].amount - f / 1e3, a > 0) {
      const { keep: u, send: l } = this.selectProofsToSend(
        o.slice(1),
        a,
        n
      );
      h.push(...l), d.push(...u);
    }
    const m = n ? this.getFeesForProofs(h) : 0;
    return U(h) < e + m && c && (h = [c]), {
      keep: t.filter((u) => !h.includes(u)),
      send: h
    };
  }
  /**
   * calculates the fees based on inputs (proofs)
   * @param proofs input proofs to calculate fees for
   * @returns fee amount
   */
  getFeesForProofs(t) {
    if (!this._keysets.length)
      throw new Error("Could not calculate fees. No keysets found");
    return new Set(t.map((r) => r.id)).forEach((r) => {
      if (!this._keysets.find((o) => o.id === r))
        throw new Error(`Could not calculate fees. No keyset found with id: ${r}`);
    }), Math.floor(
      Math.max(
        (t.reduce(
          (r, o) => r + (this._keysets.find((i) => i.id === o.id)?.input_fee_ppk || 0),
          0
        ) + 999) / 1e3,
        0
      )
    );
  }
  /**
   * calculates the fees based on inputs for a given keyset
   * @param nInputs number of inputs
   * @param keysetId keysetId used to lookup `input_fee_ppk`
   * @returns fee amount
   */
  getFeesForKeyset(t, e) {
    return Math.floor(
      Math.max(
        (t * (this._keysets.find((r) => r.id === e)?.input_fee_ppk || 0) + 999) / 1e3,
        0
      )
    );
  }
  /**
   * Splits and creates sendable tokens
   * if no amount is specified, the amount is implied by the cumulative amount of all proofs
   * if both amount and preference are set, but the preference cannot fulfill the amount, then we use the default split
   *  @param {SwapOptions} [options] - Optional parameters for configuring the swap operation
   * @returns promise of the change- and send-proofs
   */
  async swap(t, e, n) {
    let { outputAmounts: r } = n || {};
    const { includeFees: o, keysetId: i, counter: c, pubkey: a, privkey: h, proofsWeHave: d, outputData: f, p2pk: m } = n || {}, u = await this.getKeys(i), l = e;
    let w = t;
    const y = U(e);
    let g = y - w - this.getFeesForProofs(l), k = r?.sendAmounts || S(w, u.keys);
    if (o) {
      let b = this.getFeesForKeyset(k.length, u.id), I = S(b, u.keys);
      for (; this.getFeesForKeyset(k.concat(I).length, u.id) > b; )
        b++, I = S(b, u.keys);
      k = k.concat(I), w += b, g -= b;
    }
    let p;
    if (!r?.keepAmounts && d)
      p = dt(
        d,
        g,
        u.keys,
        this._denominationTarget
      );
    else if (r) {
      if (r.keepAmounts?.reduce((b, I) => b + I, 0) != g)
        throw new Error("Keep amounts do not match amount to keep");
      p = r.keepAmounts;
    }
    if (w + this.getFeesForProofs(l) > y)
      throw console.error(
        `Not enough funds available (${y}) for swap amountToSend: ${w} + fee: ${this.getFeesForProofs(
          l
        )} | length: ${l.length}`
      ), new Error("Not enough funds available for swap");
    if (w + this.getFeesForProofs(l) + g != y)
      throw new Error("Amounts do not match for swap");
    r = {
      keepAmounts: p,
      sendAmounts: k
    };
    const _ = f?.keep || this._keepFactory, T = f?.send, K = this.createSwapPayload(
      w,
      l,
      u,
      r,
      c,
      a,
      h,
      { keep: _, send: T },
      m
    ), { signatures: qt } = await this.mint.swap(K.payload), nt = K.outputData.map((b, I) => b.toProof(qt[I], u)), rt = [], ot = [], it = Array(K.keepVector.length), ct = Array(nt.length);
    return K.sortedIndices.forEach((b, I) => {
      it[b] = K.keepVector[I], ct[b] = nt[I];
    }), ct.forEach((b, I) => {
      it[I] ? rt.push(b) : ot.push(b);
    }), {
      keep: rt,
      send: ot
    };
  }
  /**
   * Restores batches of deterministic proofs until no more signatures are returned from the mint
   * @param [gapLimit=300] the amount of empty counters that should be returned before restoring ends (defaults to 300)
   * @param [batchSize=100] the amount of proofs that should be restored at a time (defaults to 100)
   * @param [counter=0] the counter that should be used as a starting point (defaults to 0)
   * @param [keysetId] which keysetId to use for the restoration. If none is passed the instance's default one will be used
   */
  async batchRestore(t = 300, e = 100, n = 0, r) {
    const o = Math.ceil(t / e), i = [];
    let c, a = 0;
    for (; a < o; ) {
      const h = await this.restore(n, e, { keysetId: r });
      h.proofs.length > 0 ? (a = 0, i.push(...h.proofs), c = h.lastCounterWithSignature) : a++, n += e;
    }
    return { proofs: i, lastCounterWithSignature: c };
  }
  /**
   * Regenerates
   * @param start set starting point for count (first cycle for each keyset should usually be 0)
   * @param count set number of blinded messages that should be generated
   * @param options.keysetId set a custom keysetId to restore from. keysetIds can be loaded with `CashuMint.getKeySets()`
   */
  async restore(t, e, n) {
    const { keysetId: r } = n || {}, o = await this.getKeys(r);
    if (!this._seed)
      throw new Error("CashuWallet must be initialized with a seed to use restore");
    const i = Array(e).fill(1), c = q.createDeterministicData(
      i.length,
      this._seed,
      t,
      o,
      i
    ), { outputs: a, signatures: h } = await this.mint.restore({
      outputs: c.map((u) => u.blindedMessage)
    }), d = {};
    a.forEach((u, l) => d[u.B_] = h[l]);
    const f = [];
    let m;
    for (let u = 0; u < c.length; u++) {
      const l = d[c[u].blindedMessage.B_];
      l && (m = t + u, c[u].blindedMessage.amount = l.amount, f.push(c[u].toProof(l, o)));
    }
    return {
      proofs: f,
      lastCounterWithSignature: m
    };
  }
  /**
   * Requests a mint quote form the mint. Response returns a Lightning payment request for the requested given amount and unit.
   * @param amount Amount requesting for mint.
   * @param description optional description for the mint quote
   * @param pubkey optional public key to lock the quote to
   * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit
   */
  async createMintQuote(t, e) {
    const n = {
      unit: this._unit,
      amount: t,
      description: e
    };
    return await this.mint.createMintQuote(n);
  }
  /**
   * Requests a mint quote from the mint that is locked to a public key.
   * @param amount Amount requesting for mint.
   * @param pubkey public key to lock the quote to
   * @param description optional description for the mint quote
   * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit.
   * The quote will be locked to the specified `pubkey`.
   */
  async createLockedMintQuote(t, e, n) {
    const { supported: r } = (await this.getMintInfo()).isSupported(20);
    if (!r)
      throw new Error("Mint does not support NUT-20");
    const o = {
      unit: this._unit,
      amount: t,
      description: n,
      pubkey: e
    }, i = await this.mint.createMintQuote(o);
    if (!i.pubkey)
      throw new Error("Mint returned unlocked mint quote");
    return i;
  }
  /**
   * Gets an existing mint quote from the mint.
   * @param quote Quote ID
   * @returns the mint will create and return a Lightning invoice for the specified amount
   */
  async checkMintQuote(t) {
    return await this.mint.checkMintQuote(t);
  }
  async mintProofs(t, e, n) {
    let { outputAmounts: r } = n || {};
    const { counter: o, pubkey: i, p2pk: c, keysetId: a, proofsWeHave: h, outputData: d, privateKey: f } = n || {}, m = await this.getKeys(a);
    !r && h && (r = {
      keepAmounts: dt(h, t, m.keys, this._denominationTarget),
      sendAmounts: []
    });
    let u = [];
    if (d)
      if (z(d)) {
        const y = S(t, m.keys, r?.keepAmounts);
        for (let g = 0; g < y.length; g++)
          u.push(d(y[g], m));
      } else
        u = d;
    else if (this._keepFactory) {
      const y = S(t, m.keys, r?.keepAmounts);
      for (let g = 0; g < y.length; g++)
        u.push(this._keepFactory(y[g], m));
    } else
      u = this.createOutputData(
        t,
        m,
        o,
        i,
        r?.keepAmounts,
        c
      );
    let l;
    if (typeof e != "string") {
      if (!f)
        throw new Error("Can not sign locked quote without private key");
      const y = u.map((k) => k.blindedMessage), g = ge(f, e.quote, y);
      l = {
        outputs: y,
        quote: e.quote,
        signature: g
      };
    } else
      l = {
        outputs: u.map((y) => y.blindedMessage),
        quote: e
      };
    const { signatures: w } = await this.mint.mint(l);
    return u.map((y, g) => y.toProof(w[g], m));
  }
  /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order to pay a Lightning invoice.
   * @param invoice LN invoice that needs to get a fee estimate
   * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve
   */
  async createMeltQuote(t) {
    const e = {
      unit: this._unit,
      request: t
    };
    return await this.mint.createMeltQuote(e);
  }
  /**
   * Requests a multi path melt quote from the mint.
   * @param invoice LN invoice that needs to get a fee estimate
   * @param partialAmount the partial amount of the invoice's total to be paid by this instance
   * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve
   */
  async createMultiPathMeltQuote(t, e) {
    const { supported: n, params: r } = (await this.lazyGetMintInfo()).isSupported(15);
    if (!n)
      throw new Error("Mint does not support NUT-15");
    if (!r?.some((h) => h.method === "bolt11" && h.unit === this.unit))
      throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);
    const i = {
      mpp: {
        amount: e
      }
    }, c = {
      unit: this._unit,
      request: t,
      options: i
    };
    return await this.mint.createMeltQuote(c);
  }
  /**
   * Return an existing melt quote from the mint.
   * @param quote ID of the melt quote
   * @returns the mint will return an existing melt quote
   */
  async checkMeltQuote(t) {
    return await this.mint.checkMeltQuote(t);
  }
  /**
   * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt quote. This function does not perform coin selection!.
   * Returns melt quote and change proofs
   * @param meltQuote ID of the melt quote
   * @param proofsToSend proofs to melt
   * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof operation
   * @returns
   */
  async meltProofs(t, e, n) {
    const { keysetId: r, counter: o, privkey: i } = n || {}, c = await this.getKeys(r), a = this.createBlankOutputs(
      U(e) - t.amount,
      c,
      o,
      this._keepFactory
    );
    i != null && (e = ut(
      e.map((f) => ({
        amount: f.amount,
        C: F(f.C),
        id: f.id,
        secret: new TextEncoder().encode(f.secret)
      })),
      i
    ).map((f) => V(f))), e = L(e);
    const h = {
      quote: t.quote,
      inputs: e,
      outputs: a.map((f) => f.blindedMessage)
    }, d = await this.mint.melt(h);
    return {
      quote: d,
      change: d.change?.map((f, m) => a[m].toProof(f, c)) ?? []
    };
  }
  /**
   * Creates a split payload
   * @param amount amount to send
   * @param proofsToSend proofs to split*
   * @param outputAmounts? optionally specify the output's amounts to keep and to send.
   * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
   * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
   * @param privkey? will create a signature on the @param proofsToSend secrets if set
   * @returns
   */
  createSwapPayload(t, e, n, r, o, i, c, a, h) {
    const d = e.reduce((p, _) => p + _.amount, 0);
    r && r.sendAmounts && !r.keepAmounts && (r.keepAmounts = S(
      d - t - this.getFeesForProofs(e),
      n.keys
    ));
    const f = d - t - this.getFeesForProofs(e);
    let m = [], u = [];
    if (a?.keep)
      if (z(a.keep)) {
        const p = a.keep;
        S(f, n.keys).forEach((T) => {
          m.push(p(T, n));
        });
      } else
        m = a.keep;
    else
      m = this.createOutputData(
        f,
        n,
        o,
        void 0,
        r?.keepAmounts,
        void 0,
        this._keepFactory
      );
    if (a?.send)
      if (z(a.send)) {
        const p = a.send;
        S(t, n.keys).forEach((T) => {
          u.push(p(T, n));
        });
      } else
        u = a.send;
    else
      u = this.createOutputData(
        t,
        n,
        o ? o + m.length : void 0,
        i,
        r?.sendAmounts,
        h
      );
    c && (e = ut(
      e.map((p) => ({
        amount: p.amount,
        C: F(p.C),
        id: p.id,
        secret: new TextEncoder().encode(p.secret)
      })),
      c
    ).map((p) => V(p))), e = L(e);
    const l = [...m, ...u], w = l.map((p, _) => _).sort(
      (p, _) => l[p].blindedMessage.amount - l[_].blindedMessage.amount
    ), y = [
      ...Array(m.length).fill(!0),
      ...Array(u.length).fill(!1)
    ], g = w.map((p) => l[p]), k = w.map((p) => y[p]);
    return {
      payload: {
        inputs: e,
        outputs: g.map((p) => p.blindedMessage)
      },
      outputData: g,
      keepVector: k,
      sortedIndices: w
    };
  }
  /**
   * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)
   * @param proofs (only the `secret` field is required)
   * @returns
   */
  async checkProofsStates(t) {
    const e = new TextEncoder(), n = t.map((i) => at(e.encode(i.secret)).toHex(!0)), r = 100, o = [];
    for (let i = 0; i < n.length; i += r) {
      const c = n.slice(i, i + r), { states: a } = await this.mint.check({
        Ys: c
      }), h = {};
      a.forEach((d) => {
        h[d.Y] = d;
      });
      for (let d = 0; d < c.length; d++) {
        const f = h[c[d]];
        if (!f)
          throw new Error("Could not find state for proof with Y: " + c[d]);
        o.push(f);
      }
    }
    return o;
  }
  /**
   * Register a callback to be called whenever a mint quote's state changes
   * @param quoteIds List of mint quote IDs that should be subscribed to
   * @param callback Callback function that will be called whenever a mint quote state changes
   * @param errorCallback
   * @returns
   */
  async onMintQuoteUpdates(t, e, n) {
    if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection)
      throw new Error("failed to establish WebSocket connection.");
    const r = this.mint.webSocketConnection.createSubscription(
      { kind: "bolt11_mint_quote", filters: t },
      e,
      n
    );
    return () => {
      this.mint.webSocketConnection?.cancelSubscription(r, e);
    };
  }
  /**
   * Register a callback to be called whenever a melt quote's state changes
   * @param quoteIds List of melt quote IDs that should be subscribed to
   * @param callback Callback function that will be called whenever a melt quote state changes
   * @param errorCallback
   * @returns
   */
  async onMeltQuotePaid(t, e, n) {
    return this.onMeltQuoteUpdates(
      [t],
      (r) => {
        r.state === N.PAID && e(r);
      },
      n
    );
  }
  /**
   * Register a callback to be called when a single mint quote gets paid
   * @param quoteId Mint quote id that should be subscribed to
   * @param callback Callback function that will be called when this mint quote gets paid
   * @param errorCallback
   * @returns
   */
  async onMintQuotePaid(t, e, n) {
    return this.onMintQuoteUpdates(
      [t],
      (r) => {
        r.state === j.PAID && e(r);
      },
      n
    );
  }
  /**
   * Register a callback to be called when a single melt quote gets paid
   * @param quoteId Melt quote id that should be subscribed to
   * @param callback Callback function that will be called when this melt quote gets paid
   * @param errorCallback
   * @returns
   */
  async onMeltQuoteUpdates(t, e, n) {
    if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection)
      throw new Error("failed to establish WebSocket connection.");
    const r = this.mint.webSocketConnection.createSubscription(
      { kind: "bolt11_melt_quote", filters: t },
      e,
      n
    );
    return () => {
      this.mint.webSocketConnection?.cancelSubscription(r, e);
    };
  }
  /**
   * Register a callback to be called whenever a subscribed proof state changes
   * @param proofs List of proofs that should be subscribed to
   * @param callback Callback function that will be called whenever a proof's state changes
   * @param errorCallback
   * @returns
   */
  async onProofStateUpdates(t, e, n) {
    if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection)
      throw new Error("failed to establish WebSocket connection.");
    const r = new TextEncoder(), o = {};
    for (let a = 0; a < t.length; a++) {
      const h = at(r.encode(t[a].secret)).toHex(!0);
      o[h] = t[a];
    }
    const i = Object.keys(o), c = this.mint.webSocketConnection.createSubscription(
      { kind: "proof_state", filters: i },
      (a) => {
        e({ ...a, proof: o[a.Y] });
      },
      n
    );
    return () => {
      this.mint.webSocketConnection?.cancelSubscription(c, e);
    };
  }
  /**
   * Creates blinded messages for a according to @param amounts
   * @param amount array of amounts to create blinded messages for
   * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
   * @param keyksetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
   * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
   * @returns blinded messages, secrets, rs, and amounts
   */
  createOutputData(t, e, n, r, o, i, c) {
    let a;
    if (r)
      a = q.createP2PKData({ pubkey: r }, t, e, o);
    else if (n || n === 0) {
      if (!this._seed)
        throw new Error("cannot create deterministic messages without seed");
      a = q.createDeterministicData(
        t,
        this._seed,
        n,
        e,
        o
      );
    } else i ? a = q.createP2PKData(i, t, e, o) : c ? a = S(t, e.keys).map((d) => c(d, e)) : a = q.createRandomData(t, e, o);
    return a;
  }
  /**
   * Creates NUT-08 blank outputs (fee returns) for a given fee reserve
   * See: https://github.com/cashubtc/nuts/blob/main/08.md
   * @param amount amount to cover with blank outputs
   * @param keysetId mint keysetId
   * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
   * @returns blinded messages, secrets, and rs
   */
  createBlankOutputs(t, e, n, r) {
    let o = Math.ceil(Math.log2(t)) || 1;
    o < 0 && (o = 0);
    const i = o ? Array(o).fill(1) : [];
    return this.createOutputData(t, e, n, void 0, i, void 0, r);
  }
}
export {
  P as CashuMint,
  Be as CashuWallet,
  le as CheckStateEnum,
  R as HttpResponseError,
  N as MeltQuoteState,
  st as MintOperationError,
  j as MintQuoteState,
  et as NetworkError,
  q as OutputData,
  Z as PaymentRequest,
  fe as PaymentRequestTransportType,
  De as decodePaymentRequest,
  Ue as deriveKeysetId,
  se as getDecodedToken,
  xe as getDecodedTokenBinary,
  Te as getEncodedToken,
  Oe as getEncodedTokenBinary,
  ee as getEncodedTokenV4,
  ae as hasValidDleq,
  Fe as injectWebSocketImpl,
  Ne as setGlobalRequestOptions
};
//# sourceMappingURL=cashu-ts.es.js.map
