{"version":3,"file":"cashu-ts.cjs.js","sources":["../src/base64.ts","../src/cbor.ts","../src/model/PaymentRequest.ts","../src/utils/Constants.ts","../src/utils.ts","../src/ws.ts","../src/WSConnection.ts","../src/model/types/mint/responses.ts","../src/model/types/wallet/paymentRequests.ts","../src/model/Errors.ts","../src/request.ts","../src/legacy/nut-05.ts","../src/legacy/nut-04.ts","../src/legacy/nut-06.ts","../src/CashuMint.ts","../src/model/MintInfo.ts","../src/crypto/nut-20.ts","../src/model/BlindedMessage.ts","../src/model/OutputData.ts","../src/CashuWallet.ts"],"sourcesContent":["import { Buffer } from 'buffer';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Buffer.from(uint8array).toString('base64');\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Buffer.from(bytes)\n\t\t.toString('base64')\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Buffer.from(base64String, 'base64');\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Buffer.from(jsonString).toString('base64'));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Buffer.from(base64urlToBase64(base64String), 'base64').toString();\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson\n};\n","type SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue =\n\t| SimpleValue\n\t| number\n\t| string\n\t| Uint8Array\n\t| Array<ResultValue>\n\t| ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: any) {\n\tconst buffer: Array<number> = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: any, buffer: Array<number>) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeUnsigned(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (typeof value === 'object') {\n\t\tencodeObject(value, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: Array<number>) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, value >> 8, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(0x1a, value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: Array<number>) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: Array<number>) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: Array<any>, buffer: Array<number>) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, length >> 8, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: { [key: string]: any }, buffer: Array<number>) {\n\tconst keys = Object.keys(value);\n\tencodeUnsigned(keys.length, buffer);\n\tbuffer[buffer.length - 1] |= 0xa0;\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<Array<ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { encodeBase64toUint8 } from '../base64';\nimport { decodeCBOR, encodeCBOR } from '../cbor';\nimport {\n\tRawPaymentRequest,\n\tRawTransport,\n\tPaymentRequestTransport,\n\tPaymentRequestTransportType\n} from './types';\nimport { Buffer } from 'buffer';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport: Array<PaymentRequestTransport>,\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: Array<string>,\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {\n\t\t\tt: this.transport.map((t: PaymentRequestTransport) => ({ t: t.type, a: t.target, g: t.tags }))\n\t\t};\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Buffer.from(data).toString('base64');\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\ttype: t.t,\n\t\t\ttarget: t.a,\n\t\t\ttags: t.g\n\t\t}));\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","/**\n * per protocol definition since tokenV3 tokens have a prefix and a version number\n */\nconst TOKEN_VERSION = 'A';\nconst TOKEN_PREFIX = 'cashu';\n\nexport { TOKEN_VERSION, TOKEN_PREFIX };\n","import { verifyDLEQProof_reblind } from '@cashu/crypto/modules/client/NUT12';\nimport { DLEQ, pointFromHex } from '@cashu/crypto/modules/common';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url\n} from './base64.js';\nimport { decodeCBOR, encodeCBOR } from './cbor.js';\nimport { PaymentRequest } from './model/PaymentRequest.js';\nimport {\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate\n} from './model/types/index.js';\nimport { TOKEN_PREFIX, TOKEN_VERSION } from './utils/Constants.js';\n\n/**\n * Splits the amount into denominations of the provided @param keyset\n * @param value amount to split\n * @param keyset keys to look up split amounts\n * @param split? optional custom split amounts\n * @param order? optional order for split amounts (default: \"asc\")\n * @returns Array of split amounts\n * @throws Error if @param split amount is greater than @param value amount\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: Array<number>,\n\torder?: 'desc' | 'asc'\n): Array<number> {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\t\tif (totalSplitAmount > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalSplitAmount} > ${value}`);\n\t\t}\n\t\tif (split.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\t\tvalue = value - sumArray(split);\n\t} else {\n\t\tsplit = [];\n\t}\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tsortedKeyAmounts.forEach((amt: number) => {\n\t\tconst q = Math.floor(value / amt);\n\t\tfor (let i = 0; i < q; ++i) split?.push(amt);\n\t\tvalue %= amt;\n\t});\n\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n * @param proofsWeHave complete set of proofs stored (from current mint)\n * @param amountToKeep amount to keep\n * @param keys keys of current keyset\n * @param targetCount the target number of proofs to reach\n * @returns an array of amounts to keep\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Array<Proof>,\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number\n): Array<number> {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: Array<number> = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\tconst sortedAmountsWeWant = amountsWeWant.sort((a, b) => a - b);\n\treturn sortedAmountsWeWant;\n}\n/**\n * returns the amounts in the keyset sorted by the order specified\n * @param keyset to search in\n * @param order order to sort the amounts in\n * @returns the amounts in the keyset sorted by the order specified\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): Array<number> {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n * @param amount amount to check\n * @param keyset to search in\n * @returns true if the amount is in the keyset, false otherwise\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n * @param bytes to convert to number\n * @returns  number\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n * @param hex to convert to number\n * @returns number\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n * @param number (bigint) to conver to hex\n * @returns hex string start-padded to 64 characters\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nfunction isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id\n * @param p Proof or list of proofs\n * @returns boolean\n */\nexport function hasNonHexId(p: Proof | Array<Proof>) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token\n * @param token to encode\n * @returns encoded token\n */\nexport function getEncodedTokenV3(token: Token): string {\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\treturn TOKEN_PREFIX + TOKEN_VERSION + encodeJsonToBase64(v3TokenObj);\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(token: Token, opts?: { version: 3 | 4 }): string {\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token);\n\t}\n\treturn getEncodedTokenV4(token);\n}\n\nexport function getEncodedTokenV4(token: Token): string {\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Array<Proof> } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00')\n\t\t\t\t\t\t\t} as V4DLEQTemplate\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t})\n\t\t)\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Array<Proof> = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e)\n\t\t\t\t\t} as SerializedDLEQ\n\t\t\t\t})\n\t\t\t});\n\t\t})\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object\n * @param token an encoded cashu token (cashuAey...)\n * @returns cashu token object\n */\nexport function getDecodedToken(token: string) {\n\t// remove prefixes\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn handleTokens(token);\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object\n * @param token an encoded cashu token (cashuAey...)\n * @returns cashu Token object\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat'\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\tconst decodedToken = tokenFromTemplate(tokenData);\n\t\treturn decodedToken;\n\t}\n\tthrow new Error('Token version is not supported');\n}\n/**\n * Returns the keyset id of a set of keys\n * @param keys keys object to derive keyset id from\n * @returns\n */\nexport function deriveKeysetId(keys: Keys) {\n\tconst pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Buffer.from(hash).toString('hex').slice(0, 14);\n\treturn '00' + hashHex;\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Array<Proof>) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: Array<string>): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Array<Proof>) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs\n * @param proofs The list of proofs that dleq should be stripped from\n */\nexport function stripDleq(proofs: Array<Proof>): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to\n * keyset `keys`\n * @param proof The proof subject to verification\n * @param keyset The Mint's keyset to be used for verification\n * @returns true if verification succeeded, false otherwise\n * @throws Error if @param proof does not match any key in @param keyset\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00')\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\tif (\n\t\t!verifyDLEQProof_reblind(\n\t\t\tnew TextEncoder().encode(proof.secret),\n\t\t\tdleq,\n\t\t\tpointFromHex(proof.C),\n\t\t\tpointFromHex(key)\n\t\t)\n\t) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction concatByteArrays(...arrays: Array<Uint8Array>): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: Array<number>) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n","let _WS: typeof WebSocket;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: any) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\treturn _WS;\n}\n","import { MessageQueue } from './utils';\nimport {\n\tJsonRpcErrorObject,\n\tJsonRpcMessage,\n\tJsonRpcNotification,\n\tJsonRpcReqParams,\n\tRpcSubId\n} from './model/types';\nimport { OnOpenError, OnOpenSuccess } from './model/types/wallet/websocket';\nimport { getWebSocketImpl } from './ws';\n\nexport class ConnectionManager {\n\tstatic instace: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instace) {\n\t\t\tConnectionManager.instace = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instace;\n\t}\n\n\tgetConnection(url: string): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: any) => any> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: any } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\n\tconstructor(url: string) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((res: OnOpenSuccess, rej: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url);\n\t\t\t\t} catch (err) {\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tres();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\trej(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMesage.bind(this),\n\t\t\t\t\t\t\t0\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = () => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthrow new Error('Socket not open...');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener(subId: string, callback: (payload: any) => any) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(callback);\n\t}\n\n\t//TODO: Move to RPCManagerClass\n\tprivate addRpcListener(\n\t\tcallback: () => any,\n\t\terrorCallback: (e: JsonRpcErrorObject) => any,\n\t\tid: Exclude<RpcSubId, null>\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\t//TODO: Move to RPCManagerClass\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener(subId: string, callback: (payload: any) => any) {\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter((fn: any) => fn !== callback);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMesage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(parsed.error);\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed as JsonRpcNotification;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: any) => any,\n\t\terrorCallback: (e: Error) => any\n\t) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\treturn errorCallback(new Error('Socket is not open'));\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\t(e: JsonRpcErrorObject) => {\n\t\t\t\terrorCallback(new Error(e.message));\n\t\t\t},\n\t\t\tthis.rpcId\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\tcancelSubscription(subId: string, callback: (payload: any) => any) {\n\t\tthis.removeListener(subId, callback);\n\t\tthis.rpcId++;\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n}\n","import { SerializedBlindedMessage } from '../wallet';\n\n/**\n * Cashu api error\n */\nexport type ApiError = {\n\t/**\n\t * Error message\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message\n\t */\n\tdetail?: string;\n};\n\n/**\n * Entries of CheckStateResponse with state of the proof\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof\n */\nexport enum CheckStateEnum {\n\tUNSPENT = 'UNSPENT',\n\tPENDING = 'PENDING',\n\tSPENT = 'SPENT'\n}\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\t/**\n\t *\n\t */\n\tstates: Array<ProofState>;\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: Array<MintContactInfo>;\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: Array<SwapMethod>;\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: Array<SwapMethod>;\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: Array<MPPMethod>;\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: Array<WebSocketSupport>;\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote\n */\nexport type MeltQuoteResponse = {\n\t/**\n\t * Quote ID\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires\n\t */\n\texpiry: number;\n\t/**\n\t * preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null, depending on which LN-backend the mint uses\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate\n\t */\n\tchange?: Array<SerializedBlindedSignature>;\n} & ApiError;\n\nexport enum MeltQuoteState {\n\tUNPAID = 'UNPAID',\n\tPENDING = 'PENDING',\n\tPAID = 'PAID'\n}\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport enum MintQuoteState {\n\tUNPAID = 'UNPAID',\n\tPAID = 'PAID',\n\tISSUED = 'ISSUED'\n}\n\n/**\n * Response from the mint after requesting a mint\n */\nexport type MintQuoteResponse = {\n\t/**\n\t * Payment request\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to\n\t */\n\tpubkey?: string;\n} & ApiError;\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a mint\n */\nexport type MintResponse = {\n\tsignatures: Array<SerializedBlindedSignature>;\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint\n */\nexport type PostRestoreResponse = {\n\toutputs: Array<SerializedBlindedMessage>;\n\tsignatures: Array<SerializedBlindedSignature>;\n};\n\n/*\n * Zero-Knowledge that BlindedSignature\n * was generated using a specific public key\n */\nexport type SerializedDLEQ = {\n\ts: string;\n\te: string;\n\tr?: string;\n};\n\n/**\n * Blinded signature as it is received from the mint\n */\nexport type SerializedBlindedSignature = {\n\t/**\n\t * keyset id for indicating which public key was used to sign the blinded message\n\t */\n\tid: string;\n\t/**\n\t * Amount denominated in Satoshi\n\t */\n\tamount: number;\n\t/**\n\t * Blinded signature\n\t */\n\tC_: string;\n\t/**\n\t * DLEQ Proof\n\t */\n\tdleq?: SerializedDLEQ;\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n};\n\n/**\n * Response from the mint after performing a split action\n */\nexport type SwapResponse = {\n\t/**\n\t * represents the outputs after the split\n\t */\n\tsignatures: Array<SerializedBlindedSignature>;\n} & ApiError;\n\n/**\n * MPP supported methods\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: Array<string>;\n};\n","import { Proof } from './index';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: Array<Array<string>>; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: Array<string>; // mints\n\td?: string; // description\n\tt: Array<RawTransport>; // transports\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: Array<Array<string>>;\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr'\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Array<Proof>;\n};\n","/** This error is thrown when a HTTP response is not 2XX nor a protocol error. */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/** This error is thrown when a network request fails. */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs.\n * See error codes [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from './model/Errors';\n\ntype RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n};\n\ntype RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n * @param options See possible options here: https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tconst errorData = await response.json().catch(() => ({ error: 'bad response' }));\n\n\t\tif (response.status === 400 && 'code' in errorData && 'detail' in errorData) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tthrow new HttpResponseError(\n\t\t\t'error' in errorData ? errorData.error : errorData.detail || 'HTTP request failed',\n\t\t\tresponse.status\n\t\t);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\tconsole.error('Failed to parse HTTP response', err);\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","import type { MeltQuoteResponse } from '../model/types/index.js';\nimport { MeltQuoteState } from '../model/types/index.js';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: MeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n): MeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tconsole.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\"\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintQuoteResponse } from '../model/types/index.js';\nimport { MintQuoteState } from '../model/types/index.js';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: MintQuoteResponse & MintQuoteResponsePaidDeprecated\n): MintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tconsole.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\"\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintContactInfo, GetInfoResponse } from '../model/types/index.js';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import { ConnectionManager, WSConnection } from './WSConnection.js';\nimport type {\n\tCheckStatePayload,\n\tCheckStateResponse,\n\tGetInfoResponse,\n\tMeltPayload,\n\tMintActiveKeys,\n\tMintAllKeysets,\n\tPostRestoreResponse,\n\tMintQuoteResponse,\n\tSerializedBlindedMessage,\n\tSwapPayload,\n\tSwapResponse,\n\tMintQuotePayload,\n\tMintPayload,\n\tMintResponse,\n\tPostRestorePayload,\n\tMeltQuotePayload,\n\tMeltQuoteResponse\n} from './model/types/index.js';\nimport { MeltQuoteState } from './model/types/index.js';\nimport request from './request.js';\nimport { isObj, joinUrls, sanitizeUrl } from './utils.js';\nimport {\n\tMeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated\n} from './legacy/nut-05.js';\nimport {\n\tMintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated\n} from './legacy/nut-04.js';\nimport { handleMintInfoContactFieldDeprecated } from './legacy/nut-06.js';\n/**\n * Class represents Cashu Mint API. This class contains Lower level functions that are implemented by CashuWallet.\n */\nclass CashuMint {\n\tprivate ws?: WSConnection;\n\t/**\n\t * @param _mintUrl requires mint URL to create this object\n\t * @param _customRequest if passed, use custom request implementation for network communication with the mint\n\t */\n\tconstructor(private _mintUrl: string, private _customRequest?: typeof request) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * fetches mints info at the /info endpoint\n\t * @param mintUrl\n\t * @param customRequest\n\t */\n\tpublic static async getInfo(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<GetInfoResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/info')\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response);\n\t\treturn data;\n\t}\n\t/**\n\t * fetches mints info at the /info endpoint\n\t */\n\tasync getInfo(): Promise<GetInfoResponse> {\n\t\treturn CashuMint.getInfo(this._mintUrl, this._customRequest);\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t * @param mintUrl\n\t * @param swapPayload payload containing inputs and outputs\n\t * @param customRequest\n\t * @returns signed outputs\n\t */\n\tpublic static async swap(\n\t\tmintUrl: string,\n\t\tswapPayload: SwapPayload,\n\t\tcustomRequest?: typeof request\n\t): Promise<SwapResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<SwapResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/swap'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: swapPayload\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error(data.detail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t * @param swapPayload payload containing inputs and outputs\n\t * @returns signed outputs\n\t */\n\tasync swap(swapPayload: SwapPayload): Promise<SwapResponse> {\n\t\treturn CashuMint.swap(this._mintUrl, swapPayload, this._customRequest);\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t * @param mintUrl\n\t * @param mintQuotePayload Payload for creating a new mint quote\n\t * @param customRequest\n\t * @returns the mint will create and return a new mint quote containing a payment request for the specified amount and unit\n\t */\n\tpublic static async createMintQuote(\n\t\tmintUrl: string,\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: typeof request\n\t): Promise<MintQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<MintQuoteResponse & MintQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintQuotePayload\n\t\t});\n\t\tconst data = handleMintQuoteResponseDeprecated(response);\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new mint quote from the mint.\n\t * @param mintQuotePayload Payload for creating a new mint quote\n\t * @returns the mint will create and return a new mint quote containing a payment request for the specified amount and unit\n\t */\n\tasync createMintQuote(mintQuotePayload: MintQuotePayload): Promise<MintQuoteResponse> {\n\t\treturn CashuMint.createMintQuote(this._mintUrl, mintQuotePayload, this._customRequest);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t * @param mintUrl\n\t * @param quote Quote ID\n\t * @param customRequest\n\t * @returns the mint will create and return a Lightning invoice for the specified amount\n\t */\n\tpublic static async checkMintQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<MintQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<MintQuoteResponse & MintQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11', quote),\n\t\t\tmethod: 'GET'\n\t\t});\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response);\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t * @param quote Quote ID\n\t * @returns the mint will create and return a Lightning invoice for the specified amount\n\t */\n\tasync checkMintQuote(quote: string): Promise<MintQuoteResponse> {\n\t\treturn CashuMint.checkMintQuote(this._mintUrl, quote, this._customRequest);\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on\n\t * @param customRequest\n\t * @returns serialized blinded signatures\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: MintPayload,\n\t\tcustomRequest?: typeof request\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t * @param mintPayload Payload containing the outputs to get blind signatures on\n\t * @returns serialized blinded signatures\n\t */\n\tasync mint(mintPayload: MintPayload) {\n\t\treturn CashuMint.mint(this._mintUrl, mintPayload, this._customRequest);\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t * @param mintUrl\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tpublic static async createMeltQuote(\n\t\tmintUrl: string,\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: typeof request\n\t): Promise<MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltQuotePayload\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new melt quote from the mint.\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tasync createMeltQuote(meltQuotePayload: MeltQuotePayload): Promise<MeltQuoteResponse> {\n\t\treturn CashuMint.createMeltQuote(this._mintUrl, meltQuotePayload, this._customRequest);\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t * @param mintUrl\n\t * @param quote Quote ID\n\t * @returns\n\t */\n\tpublic static async checkMeltQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11', quote),\n\t\t\tmethod: 'GET'\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing melt quote.\n\t * @param quote Quote ID\n\t * @returns\n\t */\n\tasync checkMeltQuote(quote: string): Promise<MeltQuoteResponse> {\n\t\treturn CashuMint.checkMeltQuote(this._mintUrl, quote, this._customRequest);\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent. The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can also contain blank outputs in order to receive back overpaid Lightning fees.\n\t * @param mintUrl\n\t * @param meltPayload\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async melt(\n\t\tmintUrl: string,\n\t\tmeltPayload: MeltPayload,\n\t\tcustomRequest?: typeof request\n\t): Promise<MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltPayload\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens matching its amount + fees\n\t * @param meltPayload\n\t * @returns\n\t */\n\tasync melt(meltPayload: MeltPayload): Promise<MeltQuoteResponse> {\n\t\treturn CashuMint.melt(this._mintUrl, meltPayload, this._customRequest);\n\t}\n\t/**\n\t * Checks if specific proofs have already been redeemed\n\t * @param mintUrl\n\t * @param checkPayload\n\t * @param customRequest\n\t * @returns redeemed and unredeemed ordered list of booleans\n\t */\n\tpublic static async check(\n\t\tmintUrl: string,\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: typeof request\n\t): Promise<CheckStateResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<CheckStateResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/checkstate'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: checkPayload\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mints public keys\n\t * @param mintUrl\n\t * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<MintActiveKeys> {\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId ? joinUrls(mintUrl, '/v1/keys', keysetId) : joinUrls(mintUrl, '/v1/keys')\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public keys\n\t * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched\n\t * @returns the mints public keys\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints keysets in no specific order\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns all the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Get the mints keysets in no specific order\n\t * @returns all the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed\n\t * @param checkPayload\n\t * @returns redeemed and unredeemed ordered list of booleans\n\t */\n\tasync check(checkPayload: CheckStatePayload): Promise<CheckStateResponse> {\n\t\treturn CashuMint.check(this._mintUrl, checkPayload, this._customRequest);\n\t}\n\n\tpublic static async restore(\n\t\tmintUrl: string,\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: typeof request\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tasync restore(restorePayload: {\n\t\toutputs: Array<SerializedBlindedMessage>;\n\t}): Promise<PostRestoreResponse> {\n\t\treturn CashuMint.restore(this._mintUrl, restorePayload, this._customRequest);\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n}\n\nexport { CashuMint };\n","import { GetInfoResponse, MPPMethod, SwapMethod, WebSocketSupport } from './types';\n\nexport class MintInfo {\n\tprivate readonly _mintInfo: GetInfoResponse;\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: Array<SwapMethod> };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: Array<WebSocketSupport> };\n\tisSupported(num: 15): { supported: boolean; params?: Array<MPPMethod> };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\tif (this._mintInfo.nuts[num]?.supported) {\n\t\t\treturn { supported: true };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo.methods };\n\t}\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n}\n","import { schnorr } from '@noble/curves/secp256k1';\nimport { SerializedBlindedMessage } from '../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha256';\n\nfunction constructMessage(\n\tquote: string,\n\tblindedMessages: Array<SerializedBlindedMessage>\n): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: Array<SerializedBlindedMessage>\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: Array<SerializedBlindedMessage>,\n\tsignature: string\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n","import { SerializedBlindedMessage } from './types/index.js';\nimport { ProjPointType } from '@noble/curves/abstract/weierstrass';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: ProjPointType<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: ProjPointType<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\tMintKeys,\n\tProof,\n\tSerializedBlindedMessage,\n\tSerializedBlindedSignature,\n\tSerializedDLEQ\n} from './types';\nimport {\n\tblindMessage,\n\tconstructProofFromPromise,\n\tserializeProof\n} from '@cashu/crypto/modules/client';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { DLEQ, pointFromHex } from '@cashu/crypto/modules/common';\nimport { verifyDLEQProof_reblind } from '@cashu/crypto/modules/client/NUT12';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\nimport { deriveBlindingFactor, deriveSecret } from '@cashu/crypto/modules/client/NUT09';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys) => OutputDataLike;\n\nexport function isOutputDataFactory(\n\tvalue: Array<OutputData> | OutputDataFactory\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(blindedMessage: SerializedBlindedMessage, blidingFactor: bigint, secret: Uint8Array) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blidingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0))\n\t\t\t\t} as SerializedDLEQ\n\t\t\t})\n\t\t} as Proof;\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: { pubkey: string; locktime?: number; refundKeys?: Array<string> },\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: Array<number>\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(\n\t\tp2pk: { pubkey: string; locktime?: number; refundKeys?: Array<string> },\n\t\tamount: number,\n\t\tkeysetId: string\n\t) {\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: Array<any> }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: p2pk.pubkey,\n\t\t\t\ttags: []\n\t\t\t}\n\t\t];\n\t\tif (p2pk.locktime) {\n\t\t\tnewSecret[1].tags.push(['locktime', p2pk.locktime]);\n\t\t}\n\t\tif (p2pk.refundKeys) {\n\t\t\tnewSecret[1].tags.push(['refund', p2pk.refundKeys]);\n\t\t}\n\t\tconst parsed = JSON.stringify(newSecret);\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes\n\t\t);\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys, customSplit?: Array<number>) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: Array<number>\n\t): Array<OutputData> {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id)\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes\n\t\t);\n\t}\n}\n","import {\n\tblindMessage,\n\tconstructProofFromPromise,\n\tserializeProof\n} from '@cashu/crypto/modules/client';\nimport { deriveBlindingFactor, deriveSecret } from '@cashu/crypto/modules/client/NUT09';\nimport { createP2PKsecret, getSignedProofs } from '@cashu/crypto/modules/client/NUT11';\nimport { verifyDLEQProof_reblind } from '@cashu/crypto/modules/client/NUT12';\nimport { hashToCurve, pointFromHex } from '@cashu/crypto/modules/common';\nimport { DLEQ, type Proof as NUT11Proof } from '@cashu/crypto/modules/common';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { CashuMint } from './CashuMint.js';\nimport { BlindedMessage } from './model/BlindedMessage.js';\nimport { MintInfo } from './model/MintInfo.js';\nimport {\n\tGetInfoResponse,\n\tMeltProofOptions,\n\tMeltQuoteState,\n\tMintProofOptions,\n\tMintQuoteResponse,\n\tMintQuoteState,\n\tOutputAmounts,\n\tProofState,\n\tReceiveOptions,\n\tRestoreOptions,\n\tSendOptions,\n\tSerializedBlindedSignature,\n\tSerializedDLEQ,\n\tSwapOptions,\n\ttype MeltPayload,\n\ttype MeltProofsResponse,\n\ttype MeltQuotePayload,\n\ttype MeltQuoteResponse,\n\ttype MintKeys,\n\ttype MintKeyset,\n\ttype MintPayload,\n\ttype MintQuotePayload,\n\ttype Proof,\n\ttype SendResponse,\n\ttype SerializedBlindedMessage,\n\ttype SwapPayload,\n\ttype Token,\n\tMPPOption,\n\tMeltQuoteOptions,\n\tSwapTransaction,\n\tLockedMintQuoteResponse\n} from './model/types/index.js';\nimport { SubscriptionCanceller } from './model/types/wallet/websocket.js';\nimport {\n\tbytesToNumber,\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tnumberToHexPadded64,\n\tsplitAmount,\n\tstripDleq,\n\tsumProofs\n} from './utils.js';\nimport { signMintQuote } from './crypto/nut-20.js';\nimport {\n\tOutputData,\n\tOutputDataFactory,\n\tOutputDataLike,\n\tisOutputDataFactory\n} from './model/OutputData.js';\n\n/**\n * The default number of proofs per denomination to keep in a wallet.\n */\nconst DEFAULT_DENOMINATION_TARGET = 3;\n\n/**\n * The default unit for the wallet, if not specified in constructor.\n */\nconst DEFAULT_UNIT = 'sat';\n\n/**\n * Class that represents a Cashu wallet.\n * This class should act as the entry point for this library\n */\nclass CashuWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: Array<MintKeyset> = [];\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = DEFAULT_UNIT;\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = DEFAULT_DENOMINATION_TARGET;\n\tprivate _keepFactory: OutputDataFactory | undefined;\n\n\tmint: CashuMint;\n\n\t/**\n\t * @param mint Cashu mint instance is used to make api calls\n\t * @param options.unit optionally set unit (default is 'sat')\n\t * @param options.keys public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets keysets from the mint (will be fetched from mint if not provided)\n\t * @param options.mintInfo mint info from the mint (will be fetched from mint if not provided)\n\t * @param options.denominationTarget target number proofs per denomination (default: see @constant DEFAULT_DENOMINATION_TARGET)\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.keepFactory A function that will be used by all parts of the library that produce proofs to be kept (change, etc.).\n\t * This can lead to poor performance, in which case the seed should be directly provided\n\t */\n\tconstructor(\n\t\tmint: CashuMint,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tkeys?: Array<MintKeys> | MintKeys;\n\t\t\tkeysets?: Array<MintKeyset>;\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tdenominationTarget?: number;\n\t\t\tkeepFactory?: OutputDataFactory;\n\t\t}\n\t) {\n\t\tthis.mint = mint;\n\t\tlet keys: Array<MintKeys> = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.unit) this._unit = options?.unit;\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t\tif (options?.mintInfo) this._mintInfo = new MintInfo(options.mintInfo);\n\t\tif (options?.denominationTarget) {\n\t\t\tthis._denominationTarget = options.denominationTarget;\n\t\t}\n\n\t\tif (options?.bip39seed) {\n\t\t\tif (options.bip39seed instanceof Uint8Array) {\n\t\t\t\tthis._seed = options.bip39seed;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('bip39seed must be a valid UInt8Array');\n\t\t}\n\t\tif (options?.keepFactory) {\n\t\t\tthis._keepFactory = options.keepFactory;\n\t\t}\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): Array<MintKeyset> {\n\t\treturn this._keysets;\n\t}\n\tget mintInfo(): MintInfo {\n\t\tif (!this._mintInfo) {\n\t\t\tthrow new Error('Mint info not loaded');\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get information about the mint\n\t * @returns mint info\n\t */\n\tasync getMintInfo(): Promise<MintInfo> {\n\t\tconst infoRes = await this.mint.getInfo();\n\t\tthis._mintInfo = new MintInfo(infoRes);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get stored information about the mint or request it if not loaded.\n\t * @returns mint info\n\t */\n\tasync lazyGetMintInfo(): Promise<MintInfo> {\n\t\tif (!this._mintInfo) {\n\t\t\treturn await this.getMintInfo();\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed in the constructor\n\t */\n\tasync loadMint() {\n\t\tawait this.getMintInfo();\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee\n\t *\n\t * Note: this function will filter out deprecated base64 keysets\n\t *\n\t * @param keysets keysets to choose from\n\t * @returns active keyset\n\t */\n\tgetActiveKeyset(keysets: Array<MintKeyset>): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0)\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet\n\t * @returns keysets with wallet's unit\n\t */\n\tasync getKeySets(): Promise<Array<MintKeyset>> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet keyset.\n\t * @returns keyset\n\t */\n\tasync getAllKeys(): Promise<Array<MintKeys>> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset.\n\t * Otherwise, we select an active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId optional keysetId to get keys for\n\t * @param forceRefresh? if set to true, it will force refresh the keyset from the mint\n\t * @returns keyset\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the first token in the token array)\n\t * @param {(string|Token)} token - Cashu token, either as string or decoded\n\t * @param {ReceiveOptions} [options] - Optional configuration for token processing\n\t * @returns New token with newly created proofs, token entries that had errors\n\t */\n\tasync receive(token: string | Token, options?: ReceiveOptions): Promise<Array<Proof>> {\n\t\tconst { requireDleq, keysetId, outputAmounts, counter, pubkey, privkey, outputData, p2pk } =\n\t\t\toptions || {};\n\n\t\tif (typeof token === 'string') {\n\t\t\ttoken = getDecodedToken(token);\n\t\t}\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (requireDleq) {\n\t\t\tif (token.proofs.some((p: Proof) => !hasValidDleq(p, keys))) {\n\t\t\t\tthrow new Error('Token contains proofs with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\tconst amount = sumProofs(token.proofs) - this.getFeesForProofs(token.proofs);\n\t\tlet newOutputData: { send: Array<OutputDataLike> | OutputDataFactory } | undefined = undefined;\n\t\tif (outputData) {\n\t\t\tnewOutputData = { send: outputData };\n\t\t} else if (this._keepFactory) {\n\t\t\tnewOutputData = { send: this._keepFactory };\n\t\t}\n\t\tconst swapTransaction = this.createSwapPayload(\n\t\t\tamount,\n\t\t\ttoken.proofs,\n\t\t\tkeys,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\tnewOutputData,\n\t\t\tp2pk\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst proofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keys));\n\t\tconst orderedProofs: Array<Proof> = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofs[o];\n\t\t});\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Send proofs of a given amount, by providing at least the required amount of proofs\n\t * @param amount amount to send\n\t * @param proofs array of proofs (accumulated amount of proofs must be >= than amount)\n\t * @param {SendOptions} [options] - Optional parameters for configuring the send operation\n\t * @returns {SendResponse}\n\t */\n\tasync send(amount: number, proofs: Array<Proof>, options?: SendOptions): Promise<SendResponse> {\n\t\tconst {\n\t\t\tproofsWeHave,\n\t\t\toffline,\n\t\t\tincludeFees,\n\t\t\tincludeDleq,\n\t\t\tkeysetId,\n\t\t\toutputAmounts,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\toutputData\n\t\t} = options || {};\n\t\tif (includeDleq) {\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tif (sumProofs(proofs) < amount) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\t\tconst { keep: keepProofsOffline, send: sendProofOffline } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamount,\n\t\t\toptions?.includeFees\n\t\t);\n\t\tconst expectedFee = includeFees ? this.getFeesForProofs(sendProofOffline) : 0;\n\t\tif (\n\t\t\t!offline &&\n\t\t\t(sumProofs(sendProofOffline) != amount + expectedFee || // if the exact amount cannot be selected\n\t\t\t\toutputAmounts ||\n\t\t\t\tpubkey ||\n\t\t\t\tprivkey ||\n\t\t\t\tkeysetId ||\n\t\t\t\toutputData) // these options require a swap\n\t\t) {\n\t\t\t// we need to swap\n\t\t\t// input selection, needs fees because of the swap\n\t\t\tconst { keep: keepProofsSelect, send: sendProofs } = this.selectProofsToSend(\n\t\t\t\tproofs,\n\t\t\t\tamount,\n\t\t\t\ttrue\n\t\t\t);\n\t\t\tproofsWeHave?.push(...keepProofsSelect);\n\n\t\t\tconst sendRes = await this.swap(amount, sendProofs, options);\n\t\t\tlet { keep, send } = sendRes;\n\t\t\tconst serialized = sendRes.serialized;\n\t\t\tkeep = keepProofsSelect.concat(keep);\n\n\t\t\tif (!includeDleq) {\n\t\t\t\tsend = stripDleq(send);\n\t\t\t}\n\n\t\t\treturn { keep, send, serialized };\n\t\t}\n\n\t\tif (sumProofs(sendProofOffline) < amount + expectedFee) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\tif (!includeDleq) {\n\t\t\treturn { keep: keepProofsOffline, send: stripDleq(sendProofOffline) };\n\t\t}\n\n\t\treturn { keep: keepProofsOffline, send: sendProofOffline };\n\t}\n\n\tselectProofsToSend(\n\t\tproofs: Array<Proof>,\n\t\tamountToSend: number,\n\t\tincludeFees?: boolean\n\t): SendResponse {\n\t\tconst sortedProofs = proofs.sort((a: Proof, b: Proof) => a.amount - b.amount);\n\t\tconst smallerProofs = sortedProofs\n\t\t\t.filter((p: Proof) => p.amount <= amountToSend)\n\t\t\t.sort((a: Proof, b: Proof) => b.amount - a.amount);\n\t\tconst biggerProofs = sortedProofs\n\t\t\t.filter((p: Proof) => p.amount > amountToSend)\n\t\t\t.sort((a: Proof, b: Proof) => a.amount - b.amount);\n\t\tconst nextBigger = biggerProofs[0];\n\t\tif (!smallerProofs.length && nextBigger) {\n\t\t\treturn {\n\t\t\t\tkeep: proofs.filter((p: Proof) => p.secret !== nextBigger.secret),\n\t\t\t\tsend: [nextBigger]\n\t\t\t};\n\t\t}\n\n\t\tif (!smallerProofs.length && !nextBigger) {\n\t\t\treturn { keep: proofs, send: [] };\n\t\t}\n\n\t\tlet remainder = amountToSend;\n\t\tlet selectedProofs = [smallerProofs[0]];\n\t\tconst returnedProofs = [];\n\t\tconst feePPK = includeFees ? this.getFeesForProofs(selectedProofs) : 0;\n\t\tremainder -= selectedProofs[0].amount - feePPK / 1000;\n\t\tif (remainder > 0) {\n\t\t\tconst { keep, send } = this.selectProofsToSend(\n\t\t\t\tsmallerProofs.slice(1),\n\t\t\t\tremainder,\n\t\t\t\tincludeFees\n\t\t\t);\n\t\t\tselectedProofs.push(...send);\n\t\t\treturnedProofs.push(...keep);\n\t\t}\n\n\t\tconst selectedFeePPK = includeFees ? this.getFeesForProofs(selectedProofs) : 0;\n\t\tif (sumProofs(selectedProofs) < amountToSend + selectedFeePPK && nextBigger) {\n\t\t\tselectedProofs = [nextBigger];\n\t\t}\n\n\t\treturn {\n\t\t\tkeep: proofs.filter((p: Proof) => !selectedProofs.includes(p)),\n\t\t\tsend: selectedProofs\n\t\t};\n\t}\n\n\t/**\n\t * calculates the fees based on inputs (proofs)\n\t * @param proofs input proofs to calculate fees for\n\t * @returns fee amount\n\t */\n\tgetFeesForProofs(proofs: Array<Proof>): number {\n\t\tif (!this._keysets.length) {\n\t\t\tthrow new Error('Could not calculate fees. No keysets found');\n\t\t}\n\t\tconst keysetIds = new Set(proofs.map((p: Proof) => p.id));\n\t\tkeysetIds.forEach((id: string) => {\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === id)) {\n\t\t\t\tthrow new Error(`Could not calculate fees. No keyset found with id: ${id}`);\n\t\t\t}\n\t\t});\n\n\t\tconst fees = Math.floor(\n\t\t\tMath.max(\n\t\t\t\t(proofs.reduce(\n\t\t\t\t\t(total: number, curr: Proof) =>\n\t\t\t\t\t\ttotal + (this._keysets.find((k: MintKeyset) => k.id === curr.id)?.input_fee_ppk || 0),\n\t\t\t\t\t0\n\t\t\t\t) +\n\t\t\t\t\t999) /\n\t\t\t\t\t1000,\n\t\t\t\t0\n\t\t\t)\n\t\t);\n\t\treturn fees;\n\t}\n\n\t/**\n\t * calculates the fees based on inputs for a given keyset\n\t * @param nInputs number of inputs\n\t * @param keysetId keysetId used to lookup `input_fee_ppk`\n\t * @returns fee amount\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\tconst fees = Math.floor(\n\t\t\tMath.max(\n\t\t\t\t(nInputs * (this._keysets.find((k: MintKeyset) => k.id === keysetId)?.input_fee_ppk || 0) +\n\t\t\t\t\t999) /\n\t\t\t\t\t1000,\n\t\t\t\t0\n\t\t\t)\n\t\t);\n\t\treturn fees;\n\t}\n\n\t/**\n\t * Splits and creates sendable tokens\n\t * if no amount is specified, the amount is implied by the cumulative amount of all proofs\n\t * if both amount and preference are set, but the preference cannot fulfill the amount, then we use the default split\n\t *  @param {SwapOptions} [options] - Optional parameters for configuring the swap operation\n\t * @returns promise of the change- and send-proofs\n\t */\n\tasync swap(amount: number, proofs: Array<Proof>, options?: SwapOptions): Promise<SendResponse> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { includeFees, keysetId, counter, pubkey, privkey, proofsWeHave, outputData, p2pk } =\n\t\t\toptions || {};\n\t\tconst keyset = await this.getKeys(keysetId);\n\n\t\tconst proofsToSend = proofs;\n\t\tlet amountToSend = amount;\n\t\tconst amountAvailable = sumProofs(proofs);\n\t\tlet amountToKeep = amountAvailable - amountToSend - this.getFeesForProofs(proofsToSend);\n\t\t// send output selection\n\t\tlet sendAmounts = outputAmounts?.sendAmounts || splitAmount(amountToSend, keyset.keys);\n\n\t\t// include the fees to spend the the outputs of the swap\n\t\tif (includeFees) {\n\t\t\tlet outputFee = this.getFeesForKeyset(sendAmounts.length, keyset.id);\n\t\t\tlet sendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(sendAmounts.concat(sendAmountsFee).length, keyset.id) > outputFee\n\t\t\t) {\n\t\t\t\toutputFee++;\n\t\t\t\tsendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\t}\n\t\t\tsendAmounts = sendAmounts.concat(sendAmountsFee);\n\t\t\tamountToSend += outputFee;\n\t\t\tamountToKeep -= outputFee;\n\t\t}\n\n\t\t// keep output selection\n\t\tlet keepAmounts;\n\t\tif (!outputAmounts?.keepAmounts && proofsWeHave) {\n\t\t\tkeepAmounts = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tamountToKeep,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget\n\t\t\t);\n\t\t} else if (outputAmounts) {\n\t\t\tif (outputAmounts.keepAmounts?.reduce((a: number, b: number) => a + b, 0) != amountToKeep) {\n\t\t\t\tthrow new Error('Keep amounts do not match amount to keep');\n\t\t\t}\n\t\t\tkeepAmounts = outputAmounts.keepAmounts;\n\t\t}\n\n\t\tif (amountToSend + this.getFeesForProofs(proofsToSend) > amountAvailable) {\n\t\t\tconsole.error(\n\t\t\t\t`Not enough funds available (${amountAvailable}) for swap amountToSend: ${amountToSend} + fee: ${this.getFeesForProofs(\n\t\t\t\t\tproofsToSend\n\t\t\t\t)} | length: ${proofsToSend.length}`\n\t\t\t);\n\t\t\tthrow new Error(`Not enough funds available for swap`);\n\t\t}\n\n\t\tif (amountToSend + this.getFeesForProofs(proofsToSend) + amountToKeep != amountAvailable) {\n\t\t\tthrow new Error('Amounts do not match for swap');\n\t\t}\n\n\t\toutputAmounts = {\n\t\t\tkeepAmounts: keepAmounts,\n\t\t\tsendAmounts: sendAmounts\n\t\t};\n\n\t\tconst keepOutputData = outputData?.keep || this._keepFactory;\n\t\tconst sendOutputData = outputData?.send;\n\n\t\tconst swapTransaction = this.createSwapPayload(\n\t\t\tamountToSend,\n\t\t\tproofsToSend,\n\t\t\tkeyset,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\t{ keep: keepOutputData, send: sendOutputData },\n\t\t\tp2pk\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst splitProofsToKeep: Array<Proof> = [];\n\t\tconst splitProofsToSend: Array<Proof> = [];\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\treorderedProofs.forEach((p, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tsplitProofsToKeep.push(p);\n\t\t\t} else {\n\t\t\t\tsplitProofsToSend.push(p);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tkeep: splitProofsToKeep,\n\t\t\tsend: splitProofsToSend\n\t\t};\n\t}\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint\n\t * @param [gapLimit=300] the amount of empty counters that should be returned before restoring ends (defaults to 300)\n\t * @param [batchSize=100] the amount of proofs that should be restored at a time (defaults to 100)\n\t * @param [counter=0] the counter that should be used as a starting point (defaults to 0)\n\t * @param [keysetId] which keysetId to use for the restoration. If none is passed the instance's default one will be used\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string\n\t): Promise<{ proofs: Array<Proof>; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Array<Proof> = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates\n\t * @param start set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count set number of blinded messages that should be generated\n\t * @param options.keysetId set a custom keysetId to restore from. keysetIds can be loaded with `CashuMint.getKeySets()`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\toptions?: RestoreOptions\n\t): Promise<{ proofs: Array<Proof>; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (!this._seed) {\n\t\t\tthrow new Error('CashuWallet must be initialized with a seed to use restore');\n\t\t}\n\t\t// create blank amounts for unknown restore amounts\n\t\tconst amounts = Array(count).fill(1);\n\t\tconst outputData = OutputData.createDeterministicData(\n\t\t\tamounts.length,\n\t\t\tthis._seed,\n\t\t\tstart,\n\t\t\tkeys,\n\t\t\tamounts\n\t\t);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage)\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Array<Proof> = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keys));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote form the mint. Response returns a Lightning payment request for the requested given amount and unit.\n\t * @param amount Amount requesting for mint.\n\t * @param description optional description for the mint quote\n\t * @param pubkey optional public key to lock the quote to\n\t * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit\n\t */\n\tasync createMintQuote(amount: number, description?: string) {\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description\n\t\t};\n\t\treturn await this.mint.createMintQuote(mintQuotePayload);\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey public key to lock the quote to\n\t * @param description optional description for the mint quote\n\t * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit.\n\t * The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string\n\t): Promise<LockedMintQuoteResponse> {\n\t\tconst { supported } = (await this.getMintInfo()).isSupported(20);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-20');\n\t\t}\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\tif (!res.pubkey) {\n\t\t\tthrow new Error('Mint returned unlocked mint quote');\n\t\t}\n\t\treturn res as LockedMintQuoteResponse;\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t * @param quote Quote ID\n\t * @returns the mint will create and return a Lightning invoice for the specified amount\n\t */\n\tasync checkMintQuote(quote: string) {\n\t\treturn await this.mint.checkMintQuote(quote);\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote\n\t * @param amount amount to request\n\t * @param {string} quote - ID of mint quote (when quote is a string)\n\t * @param {LockedMintQuote} quote - containing the quote ID and unlocking private key (when quote is a LockedMintQuote)\n\t * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof operation\n\t * @returns proofs\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: MintQuoteResponse,\n\t\toptions: MintProofOptions & { privateKey: string }\n\t): Promise<Array<Proof>>;\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string,\n\t\toptions?: MintProofOptions\n\t): Promise<Array<Proof>>;\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\toptions?: MintProofOptions & { privateKey?: string }\n\t): Promise<Array<Proof>> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { counter, pubkey, p2pk, keysetId, proofsWeHave, outputData, privateKey } = options || {};\n\n\t\tconst keyset = await this.getKeys(keysetId);\n\t\tif (!outputAmounts && proofsWeHave) {\n\t\t\toutputAmounts = {\n\t\t\t\tkeepAmounts: getKeepAmounts(proofsWeHave, amount, keyset.keys, this._denominationTarget),\n\t\t\t\tsendAmounts: []\n\t\t\t};\n\t\t}\n\t\tlet newBlindingData: Array<OutputData> = [];\n\t\tif (outputData) {\n\t\t\tif (isOutputDataFactory(outputData)) {\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\t\tnewBlindingData.push(outputData(amounts[i], keyset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewBlindingData = outputData;\n\t\t\t}\n\t\t} else if (this._keepFactory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\tnewBlindingData.push(this._keepFactory(amounts[i], keyset));\n\t\t\t}\n\t\t} else {\n\t\t\tnewBlindingData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tp2pk\n\t\t\t);\n\t\t}\n\t\tlet mintPayload: MintPayload;\n\t\tif (typeof quote !== 'string') {\n\t\t\tif (!privateKey) {\n\t\t\t\tthrow new Error('Can not sign locked quote without private key');\n\t\t\t}\n\t\t\tconst blindedMessages = newBlindingData.map((d) => d.blindedMessage);\n\t\t\tconst mintQuoteSignature = signMintQuote(privateKey, quote.quote, blindedMessages);\n\t\t\tmintPayload = {\n\t\t\t\toutputs: blindedMessages,\n\t\t\t\tquote: quote.quote,\n\t\t\t\tsignature: mintQuoteSignature\n\t\t\t};\n\t\t} else {\n\t\t\tmintPayload = {\n\t\t\t\toutputs: newBlindingData.map((d) => d.blindedMessage),\n\t\t\t\tquote: quote\n\t\t\t};\n\t\t}\n\t\tconst { signatures } = await this.mint.mint(mintPayload);\n\t\treturn newBlindingData.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order to pay a Lightning invoice.\n\t * @param invoice LN invoice that needs to get a fee estimate\n\t * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn meltQuote;\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t * @param invoice LN invoice that needs to get a fee estimate\n\t * @param partialAmount the partial amount of the invoice's total to be paid by this instance\n\t * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number\n\t): Promise<MeltQuoteResponse> {\n\t\tconst { supported, params } = (await this.lazyGetMintInfo()).isSupported(15);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-15');\n\t\t}\n\t\tif (!params?.some((p) => p.method === 'bolt11' && p.unit === this.unit)) {\n\t\t\tthrow new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);\n\t\t}\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn meltQuote;\n\t}\n\n\t/**\n\t * Return an existing melt quote from the mint.\n\t * @param quote ID of the melt quote\n\t * @returns the mint will return an existing melt quote\n\t */\n\tasync checkMeltQuote(quote: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuote = await this.mint.checkMeltQuote(quote);\n\t\treturn meltQuote;\n\t}\n\n\t/**\n\t * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt quote. This function does not perform coin selection!.\n\t * Returns melt quote and change proofs\n\t * @param meltQuote ID of the melt quote\n\t * @param proofsToSend proofs to melt\n\t * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof operation\n\t * @returns\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Array<Proof>,\n\t\toptions?: MeltProofOptions\n\t): Promise<MeltProofsResponse> {\n\t\tconst { keysetId, counter, privkey } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tconst outputData = this.createBlankOutputs(\n\t\t\tsumProofs(proofsToSend) - meltQuote.amount,\n\t\t\tkeys,\n\t\t\tcounter,\n\t\t\tthis._keepFactory\n\t\t);\n\t\tif (privkey != undefined) {\n\t\t\tproofsToSend = getSignedProofs(\n\t\t\t\tproofsToSend.map((p: Proof) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tamount: p.amount,\n\t\t\t\t\t\tC: pointFromHex(p.C),\n\t\t\t\t\t\tid: p.id,\n\t\t\t\t\t\tsecret: new TextEncoder().encode(p.secret)\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tprivkey\n\t\t\t).map((p: NUT11Proof) => serializeProof(p));\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage)\n\t\t};\n\t\tconst meltResponse = await this.mint.melt(meltPayload);\n\t\treturn {\n\t\t\tquote: meltResponse,\n\t\t\tchange: meltResponse.change?.map((s, i) => outputData[i].toProof(s, keys)) ?? []\n\t\t};\n\t}\n\n\t/**\n\t * Creates a split payload\n\t * @param amount amount to send\n\t * @param proofsToSend proofs to split*\n\t * @param outputAmounts? optionally specify the output's amounts to keep and to send.\n\t * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n\t * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!\n\t * @param privkey? will create a signature on the @param proofsToSend secrets if set\n\t * @returns\n\t */\n\tprivate createSwapPayload(\n\t\tamount: number,\n\t\tproofsToSend: Array<Proof>,\n\t\tkeyset: MintKeys,\n\t\toutputAmounts?: OutputAmounts,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\tprivkey?: string,\n\t\tcustomOutputData?: {\n\t\t\tkeep?: Array<OutputDataLike> | OutputDataFactory;\n\t\t\tsend?: Array<OutputDataLike> | OutputDataFactory;\n\t\t},\n\t\tp2pk?: { pubkey: string; locktime?: number; refundKeys?: Array<string> }\n\t): SwapTransaction {\n\t\tconst totalAmount = proofsToSend.reduce((total: number, curr: Proof) => total + curr.amount, 0);\n\t\tif (outputAmounts && outputAmounts.sendAmounts && !outputAmounts.keepAmounts) {\n\t\t\toutputAmounts.keepAmounts = splitAmount(\n\t\t\t\ttotalAmount - amount - this.getFeesForProofs(proofsToSend),\n\t\t\t\tkeyset.keys\n\t\t\t);\n\t\t}\n\t\tconst keepAmount = totalAmount - amount - this.getFeesForProofs(proofsToSend);\n\t\tlet keepOutputData: Array<OutputDataLike> = [];\n\t\tlet sendOutputData: Array<OutputDataLike> = [];\n\n\t\tif (customOutputData?.keep) {\n\t\t\tif (isOutputDataFactory(customOutputData.keep)) {\n\t\t\t\tconst factory = customOutputData.keep;\n\t\t\t\tconst amounts = splitAmount(keepAmount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tkeepOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tkeepOutputData = customOutputData.keep;\n\t\t\t}\n\t\t} else {\n\t\t\tkeepOutputData = this.createOutputData(\n\t\t\t\tkeepAmount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tundefined,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tundefined,\n\t\t\t\tthis._keepFactory\n\t\t\t);\n\t\t}\n\n\t\tif (customOutputData?.send) {\n\t\t\tif (isOutputDataFactory(customOutputData.send)) {\n\t\t\t\tconst factory = customOutputData.send;\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tsendOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsendOutputData = customOutputData.send;\n\t\t\t}\n\t\t} else {\n\t\t\tsendOutputData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter ? counter + keepOutputData.length : undefined,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.sendAmounts,\n\t\t\t\tp2pk\n\t\t\t);\n\t\t}\n\n\t\tif (privkey) {\n\t\t\tproofsToSend = getSignedProofs(\n\t\t\t\tproofsToSend.map((p: Proof) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tamount: p.amount,\n\t\t\t\t\t\tC: pointFromHex(p.C),\n\t\t\t\t\t\tid: p.id,\n\t\t\t\t\t\tsecret: new TextEncoder().encode(p.secret)\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tprivkey\n\t\t\t).map((p: NUT11Proof) => serializeProof(p));\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\tconst mergedBlindingData = [...keepOutputData, ...sendOutputData];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount\n\t\t\t);\n\t\tconst keepVector = [\n\t\t\t...Array(keepOutputData.length).fill(true),\n\t\t\t...Array(sendOutputData.length).fill(false)\n\t\t];\n\n\t\tconst sortedOutputData = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector = indices.map((i) => keepVector[i]);\n\n\t\treturn {\n\t\t\tpayload: {\n\t\t\t\tinputs: proofsToSend,\n\t\t\t\toutputs: sortedOutputData.map((d) => d.blindedMessage)\n\t\t\t},\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices\n\t\t};\n\t}\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t * @param proofs (only the `secret` field is required)\n\t * @returns\n\t */\n\tasync checkProofsStates(proofs: Array<Proof>): Promise<Array<ProofState>> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Proof) => hashToCurve(enc.encode(p.secret)).toHex(true));\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: Array<ProofState> = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tif (!state) {\n\t\t\t\t\tthrow new Error('Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\t}\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes\n\t * @param quoteIds List of mint quote IDs that should be subscribed to\n\t * @param callback Callback function that will be called whenever a mint quote state changes\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuoteUpdates(\n\t\tquoteIds: Array<string>,\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_mint_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quote's state changes\n\t * @param quoteIds List of melt quote IDs that should be subscribed to\n\t * @param callback Callback function that will be called whenever a melt quote state changes\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMeltQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid\n\t * @param quoteId Mint quote id that should be subscribed to\n\t * @param callback Callback function that will be called when this mint quote gets paid\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMintQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid\n\t * @param quoteId Melt quote id that should be subscribed to\n\t * @param callback Callback function that will be called when this melt quote gets paid\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuoteUpdates(\n\t\tquoteIds: Array<string>,\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_melt_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes\n\t * @param proofs List of proofs that should be subscribed to\n\t * @param callback Callback function that will be called whenever a proof's state changes\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onProofStateUpdates(\n\t\tproofs: Array<Proof>,\n\t\tcallback: (payload: ProofState & { proof: Proof }) => void,\n\t\terrorCallback: (e: Error) => void\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: { [y: string]: Proof } = {};\n\t\tfor (let i = 0; i < proofs.length; i++) {\n\t\t\tconst y = hashToCurve(enc.encode(proofs[i].secret)).toHex(true);\n\t\t\tproofMap[y] = proofs[i];\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'proof_state', filters: ys },\n\t\t\t(p: ProofState) => {\n\t\t\t\tcallback({ ...p, proof: proofMap[p.Y] });\n\t\t\t},\n\t\t\terrorCallback\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Creates blinded messages for a according to @param amounts\n\t * @param amount array of amounts to create blinded messages for\n\t * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n\t * @param keyksetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint\n\t * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!\n\t * @returns blinded messages, secrets, rs, and amounts\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\toutputAmounts?: Array<number>,\n\t\tp2pk?: { pubkey: string; locktime?: number; refundKeys?: Array<string> },\n\t\tfactory?: OutputDataFactory\n\t): Array<OutputDataLike> {\n\t\tlet outputData: Array<OutputDataLike>;\n\t\tif (pubkey) {\n\t\t\toutputData = OutputData.createP2PKData({ pubkey }, amount, keyset, outputAmounts);\n\t\t} else if (counter || counter === 0) {\n\t\t\tif (!this._seed) {\n\t\t\t\tthrow new Error('cannot create deterministic messages without seed');\n\t\t\t}\n\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\tamount,\n\t\t\t\tthis._seed,\n\t\t\t\tcounter,\n\t\t\t\tkeyset,\n\t\t\t\toutputAmounts\n\t\t\t);\n\t\t} else if (p2pk) {\n\t\t\toutputData = OutputData.createP2PKData(p2pk, amount, keyset, outputAmounts);\n\t\t} else if (factory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\toutputData = amounts.map((a) => factory(a, keyset));\n\t\t} else {\n\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputAmounts);\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates NUT-08 blank outputs (fee returns) for a given fee reserve\n\t * See: https://github.com/cashubtc/nuts/blob/main/08.md\n\t * @param amount amount to cover with blank outputs\n\t * @param keysetId mint keysetId\n\t * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n\t * @returns blinded messages, secrets, and rs\n\t */\n\tprivate createBlankOutputs(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tfactory?: OutputDataFactory\n\t): Array<OutputDataLike> {\n\t\tlet count = Math.ceil(Math.log2(amount)) || 1;\n\t\t//Prevent count from being -Infinity\n\t\tif (count < 0) {\n\t\t\tcount = 0;\n\t\t}\n\t\tconst amounts = count ? Array(count).fill(1) : [];\n\t\treturn this.createOutputData(amount, keyset, counter, undefined, amounts, undefined, factory);\n\t}\n}\n\nexport { CashuWallet };\n"],"names":["encodeUint8toBase64Url","bytes","Buffer","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","str","isResultKeyType","value","encodeCBOR","buffer","encodeItem","encodeUnsigned","encodeString","encodeArray","encodeByteString","encodeObject","length","i","utf8","item","keys","key","decodeCBOR","data","view","decodeItem","offset","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","decodeLength","hi","lo","newOffset","array","currentOffset","result","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","PaymentRequest","transport","id","amount","unit","mints","description","singleUse","rawRequest","type","rawPaymentRequest","transports","t","encodedRequest","encodedData","decoded","TOKEN_VERSION","TOKEN_PREFIX","splitAmount","keyset","split","order","totalSplitAmount","sumArray","amt","hasCorrespondingKey","getKeysetAmounts","q","a","b","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","p","countWeHave","countWeWant","amountDiff","k","bytesToNumber","hexToNumber","bytesToHex","hex","numberToHexPadded64","number","isValidHex","hasNonHexId","proof","getEncodedTokenV3","token","v3TokenObj","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","prefix","version","base64Data","idMap","mint","hexToBytes","tokenFromTemplate","template","proofs","decodedToken","getDecodedToken","handleTokens","encodedToken","parsedV3Token","entry","tokenObj","uInt8Token","tokenData","deriveKeysetId","pubkeysConcat","pubKey","prev","curr","mergeUInt8Arrays","hash","sha256","a1","a2","mergedArray","isObj","v","joinUrls","parts","part","sanitizeUrl","url","sumProofs","acc","decodePaymentRequest","paymentRequest","MessageNode","message","node","MessageQueue","messageNode","newNode","stripDleq","newP","hasValidDleq","dleq","verifyDLEQProof_reblind","pointFromHex","concatByteArrays","arrays","totalLength","c","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","arr","_WS","injectWebSocketImpl","ws","getWebSocketImpl","ConnectionManager","newConn","WSConnection","res","rej","err","e","method","params","subId","callback","errorCallback","fn","parsed","notification","cb","CheckStateEnum","MeltQuoteState","MintQuoteState","PaymentRequestTransportType","HttpResponseError","status","NetworkError","MintOperationError","code","detail","globalRequestOptions","setGlobalRequestOptions","options","_request","endpoint","requestBody","requestHeaders","body","headers","response","errorData","request","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","CashuMint","_mintUrl","_customRequest","mintUrl","customRequest","swapPayload","mintQuotePayload","quote","mintPayload","meltQuotePayload","meltPayload","checkPayload","keysetId","restorePayload","wsSegment","MintInfo","info","num","mintMeltInfo","constructMessage","blindedMessages","blindedMessage","msgbytes","signMintQuote","privkey","privkeyBytes","signature","schnorr","BlindedMessage","B_","isOutputDataFactory","OutputData","blidingFactor","secret","sig","blindSignature","A","constructProofFromPromise","serializeProof","p2pk","customSplit","newSecret","randomBytes","secretBytes","r","blindMessage","randomHex","seed","counter","deriveSecret","secretBytesAsHex","utf8SecretBytes","deterministicR","deriveBlindingFactor","DEFAULT_DENOMINATION_TARGET","DEFAULT_UNIT","CashuWallet","infoRes","keysets","activeKeysets","activeKeyset","unitKeysets","forceRefresh","requireDleq","outputAmounts","pubkey","outputData","newOutputData","swapTransaction","signatures","d","orderedProofs","s","o","offline","includeFees","includeDleq","keepProofsOffline","sendProofOffline","expectedFee","keepProofsSelect","sendProofs","sendRes","keep","send","serialized","amountToSend","sortedProofs","smallerProofs","nextBigger","remainder","selectedProofs","returnedProofs","feePPK","selectedFeePPK","total","nInputs","proofsToSend","amountAvailable","sendAmounts","outputFee","sendAmountsFee","keepAmounts","keepOutputData","sendOutputData","swapProofs","splitProofsToKeep","splitProofsToSend","reorderedKeepVector","reorderedProofs","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","start","count","amounts","outputs","signatureMap","matchingSig","supported","privateKey","newBlindingData","mintQuoteSignature","invoice","millisatPartialAmount","meltOptions","meltQuote","getSignedProofs","meltResponse","customOutputData","totalAmount","keepAmount","factory","mergedBlindingData","indices","_","keepVector","sortedOutputData","sortedKeepVector","enc","Ys","hashToCurve","BATCH_SIZE","states","YsSlice","batchStates","stateMap","j","state","quoteIds","quoteId","proofMap","y","ys"],"mappings":"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"}