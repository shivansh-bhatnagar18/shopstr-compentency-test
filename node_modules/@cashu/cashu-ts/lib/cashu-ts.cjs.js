"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const Me=require("@cashu/crypto/modules/client/NUT12"),x=require("@cashu/crypto/modules/common"),E=require("@noble/curves/abstract/utils"),le=require("@noble/hashes/sha256"),H=require("buffer"),B=require("@cashu/crypto/modules/client"),oe=require("@cashu/crypto/modules/client/NUT11"),ve=require("@noble/curves/secp256k1"),A=require("@noble/hashes/utils"),ie=require("@cashu/crypto/modules/client/NUT09");function xe(s){return H.Buffer.from(s).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function fe(s){return H.Buffer.from(s,"base64")}function De(s){const e=JSON.stringify(s);return Oe(H.Buffer.from(e).toString("base64"))}function Ue(s){const e=H.Buffer.from(Be(s),"base64").toString();return JSON.parse(e)}function Be(s){return s.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function Oe(s){return s.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function Fe(s){return typeof s=="number"||typeof s=="string"}function J(s){const e=[];return Y(s,e),new Uint8Array(e)}function Y(s,e){if(s===null)e.push(246);else if(s===void 0)e.push(247);else if(typeof s=="boolean")e.push(s?245:244);else if(typeof s=="number")pe(s,e);else if(typeof s=="string")me(s,e);else if(Array.isArray(s))Ke(s,e);else if(s instanceof Uint8Array)Ne(s,e);else if(typeof s=="object")Re(s,e);else throw new Error("Unsupported type")}function pe(s,e){if(s<24)e.push(s);else if(s<256)e.push(24,s);else if(s<65536)e.push(25,s>>8,s&255);else if(s<4294967296)e.push(26,s>>24,s>>16&255,s>>8&255,s&255);else throw new Error("Unsupported integer size")}function Ne(s,e){const t=s.length;if(t<24)e.push(64+t);else if(t<256)e.push(88,t);else if(t<65536)e.push(89,t>>8&255,t&255);else if(t<4294967296)e.push(90,t>>24&255,t>>16&255,t>>8&255,t&255);else throw new Error("Byte string too long to encode");for(let n=0;n<s.length;n++)e.push(s[n])}function me(s,e){const t=new TextEncoder().encode(s),n=t.length;if(n<24)e.push(96+n);else if(n<256)e.push(120,n);else if(n<65536)e.push(121,n>>8&255,n&255);else if(n<4294967296)e.push(122,n>>24&255,n>>16&255,n>>8&255,n&255);else throw new Error("String too long to encode");for(let r=0;r<t.length;r++)e.push(t[r])}function Ke(s,e){const t=s.length;if(t<24)e.push(128|t);else if(t<256)e.push(152,t);else if(t<65536)e.push(153,t>>8,t&255);else throw new Error("Unsupported array length");for(const n of s)Y(n,e)}function Re(s,e){const t=Object.keys(s);pe(t.length,e),e[e.length-1]|=160;for(const n of t)me(n,e),Y(s[n],e)}function X(s){const e=new DataView(s.buffer,s.byteOffset,s.byteLength);return L(e,0).value}function L(s,e){if(e>=s.byteLength)throw new Error("Unexpected end of data");const t=s.getUint8(e++),n=t>>5,r=t&31;switch(n){case 0:return Qe(s,e,r);case 1:return He(s,e,r);case 2:return We(s,e,r);case 3:return Le(s,e,r);case 4:return je(s,e,r);case 5:return Ce(s,e,r);case 7:return $e(s,e,r);default:throw new Error(`Unsupported major type: ${n}`)}}function K(s,e,t){if(t<24)return{value:t,offset:e};if(t===24)return{value:s.getUint8(e++),offset:e};if(t===25){const n=s.getUint16(e,!1);return e+=2,{value:n,offset:e}}if(t===26){const n=s.getUint32(e,!1);return e+=4,{value:n,offset:e}}if(t===27){const n=s.getUint32(e,!1),r=s.getUint32(e+4,!1);return e+=8,{value:n*2**32+r,offset:e}}throw new Error(`Unsupported length: ${t}`)}function Qe(s,e,t){const{value:n,offset:r}=K(s,e,t);return{value:n,offset:r}}function He(s,e,t){const{value:n,offset:r}=K(s,e,t);return{value:-1-n,offset:r}}function We(s,e,t){const{value:n,offset:r}=K(s,e,t);if(r+n>s.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(s.buffer,s.byteOffset+r,n),offset:r+n}}function Le(s,e,t){const{value:n,offset:r}=K(s,e,t);if(r+n>s.byteLength)throw new Error("String length exceeds data length");const o=new Uint8Array(s.buffer,s.byteOffset+r,n);return{value:new TextDecoder().decode(o),offset:r+n}}function je(s,e,t){const{value:n,offset:r}=K(s,e,t),o=[];let i=r;for(let c=0;c<n;c++){const a=L(s,i);o.push(a.value),i=a.offset}return{value:o,offset:i}}function Ce(s,e,t){const{value:n,offset:r}=K(s,e,t),o={};let i=r;for(let c=0;c<n;c++){const a=L(s,i);if(!Fe(a.value))throw new Error("Invalid key type");const h=L(s,a.offset);o[a.value]=h.value,i=h.offset}return{value:o,offset:i}}function ze(s){const e=(s&31744)>>10,t=s&1023,n=s&32768?-1:1;return e===0?n*2**-14*(t/1024):e===31?t?NaN:n*(1/0):n*2**(e-15)*(1+t/1024)}function $e(s,e,t){if(t<24)switch(t){case 20:return{value:!1,offset:e};case 21:return{value:!0,offset:e};case 22:return{value:null,offset:e};case 23:return{value:void 0,offset:e};default:throw new Error(`Unknown simple value: ${t}`)}if(t===24)return{value:s.getUint8(e++),offset:e};if(t===25){const n=ze(s.getUint16(e,!1));return e+=2,{value:n,offset:e}}if(t===26){const n=s.getFloat32(e,!1);return e+=4,{value:n,offset:e}}if(t===27){const n=s.getFloat64(e,!1);return e+=8,{value:n,offset:e}}throw new Error(`Unknown simple or float value: ${t}`)}class j{constructor(e,t,n,r,o,i,c=!1){this.transport=e,this.id=t,this.amount=n,this.unit=r,this.mints=o,this.description=i,this.singleUse=c}toRawRequest(){const e={t:this.transport.map(t=>({t:t.type,a:t.target,g:t.tags}))};return this.id&&(e.i=this.id),this.amount&&(e.a=this.amount),this.unit&&(e.u=this.unit),this.mints&&(e.m=this.mints),this.description&&(e.d=this.description),this.singleUse&&(e.s=this.singleUse),e}toEncodedRequest(){const e=this.toRawRequest(),t=J(e);return"creqA"+H.Buffer.from(t).toString("base64")}getTransport(e){return this.transport.find(t=>t.type===e)}static fromRawRequest(e){const t=e.t.map(n=>({type:n.t,target:n.a,tags:n.g}));return new j(t,e.i,e.a,e.u,e.m,e.d,e.s)}static fromEncodedRequest(e){if(!e.startsWith("creq"))throw new Error("unsupported pr: invalid prefix");if(e[4]!=="A")throw new Error("unsupported pr version");const n=e.slice(5),r=fe(n),o=X(r);return this.fromRawRequest(o)}}const Ve="A",Ge="cashu";function q(s,e,t,n){if(t){const o=ue(t);if(o>s)throw new Error(`Split is greater than total amount: ${o} > ${s}`);if(t.some(i=>!ge(i,e)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");s=s-ue(t)}else t=[];return ye(e,"desc").forEach(o=>{const i=Math.floor(s/o);for(let c=0;c<i;++c)t?.push(o);s%=o}),t.sort((o,i)=>o-i)}function ce(s,e,t,n){const r=[],o=s.map(h=>h.amount);ye(t,"asc").forEach(h=>{const d=o.filter(m=>m===h).length,f=Math.max(n-d,0);for(let m=0;m<f&&!(r.reduce((u,l)=>u+l,0)+h>e);++m)r.push(h)});const c=e-r.reduce((h,d)=>h+d,0);return c&&q(c,t).forEach(d=>{r.push(d)}),r.sort((h,d)=>h-d)}function ye(s,e="desc"){return e=="desc"?Object.keys(s).map(t=>parseInt(t)).sort((t,n)=>n-t):Object.keys(s).map(t=>parseInt(t)).sort((t,n)=>t-n)}function ge(s,e){return s in e}function Je(s){return we(E.bytesToHex(s))}function we(s){return BigInt(`0x${s}`)}function Ye(s){return s.toString(16).padStart(64,"0")}function ae(s){return/^[a-f0-9]*$/i.test(s)}function ke(s){return Array.isArray(s)?s.some(e=>!ae(e.id)):ae(s.id)}function Xe(s){const e={token:[{mint:s.mint,proofs:s.proofs}]};return s.unit&&(e.unit=s.unit),s.memo&&(e.memo=s.memo),Ge+Ve+De(e)}function Ze(s,e){if(ke(s.proofs)||e?.version===3){if(e?.version===4)throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");return Xe(s)}return be(s)}function be(s){if(s.proofs.forEach(c=>{if(c.dleq&&c.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),ke(s.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");const t=_e(s),n=J(t),r="cashu",o="B",i=xe(n);return r+o+i}function _e(s){const e={},t=s.mint;for(let r=0;r<s.proofs.length;r++){const o=s.proofs[r];e[o.id]?e[o.id].push(o):e[o.id]=[o]}const n={m:t,u:s.unit||"sat",t:Object.keys(e).map(r=>({i:E.hexToBytes(r),p:e[r].map(o=>({a:o.amount,s:o.secret,c:E.hexToBytes(o.C),...o.dleq&&{d:{e:E.hexToBytes(o.dleq.e),s:E.hexToBytes(o.dleq.s),r:E.hexToBytes(o.dleq.r??"00")}}}))}))};return s.memo&&(n.d=s.memo),n}function Ee(s){const e=[];s.t.forEach(n=>n.p.forEach(r=>{e.push({secret:r.s,C:E.bytesToHex(r.c),amount:r.a,id:E.bytesToHex(n.i),...r.d&&{dleq:{r:E.bytesToHex(r.d.r),s:E.bytesToHex(r.d.s),e:E.bytesToHex(r.d.e)}}})}));const t={mint:s.m,proofs:e,unit:s.u||"sat"};return s.d&&(t.memo=s.d),t}function Pe(s){return["web+cashu://","cashu://","cashu:","cashu"].forEach(t=>{s.startsWith(t)&&(s=s.slice(t.length))}),et(s)}function et(s){const e=s.slice(0,1),t=s.slice(1);if(e==="A"){const n=Ue(t);if(n.token.length>1)throw new Error("Multi entry token are not supported");const r=n.token[0],o={mint:r.mint,proofs:r.proofs,unit:n.unit||"sat"};return n.memo&&(o.memo=n.memo),o}else if(e==="B"){const n=fe(t),r=X(n);return Ee(r)}throw new Error("Token version is not supported")}function tt(s){const e=Object.entries(s).sort((r,o)=>+r[0]-+o[0]).map(([,r])=>E.hexToBytes(r)).reduce((r,o)=>st(r,o),new Uint8Array),t=le.sha256(e);return"00"+Buffer.from(t).toString("hex").slice(0,14)}function st(s,e){const t=new Uint8Array(s.length+e.length);return t.set(s),t.set(e,s.length),t}function v(s){return typeof s=="object"}function S(...s){return s.map(e=>e.replace(/(^\/+|\/+$)/g,"")).join("/")}function nt(s){return s.replace(/\/$/,"")}function U(s){return s.reduce((e,t)=>e+t.amount,0)}function rt(s){return j.fromEncodedRequest(s)}class ot{get value(){return this._value}set value(e){this._value=e}get next(){return this._next}set next(e){this._next=e}constructor(e){this._value=e,this._next=null}}class it{get first(){return this._first}set first(e){this._first=e}get last(){return this._last}set last(e){this._last=e}get size(){return this._size}set size(e){this._size=e}constructor(){this._first=null,this._last=null,this._size=0}enqueue(e){const t=new ot(e);return this._size===0||!this._last?(this._first=t,this._last=t):(this._last.next=t,this._last=t),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const e=this._first;return this._first=e.next,e.next=null,this._size--,e.value}}function W(s){return s.map(e=>{const t={...e};return delete t.dleq,t})}function Se(s,e){if(s.dleq==null)return!1;const t={e:E.hexToBytes(s.dleq.e),s:E.hexToBytes(s.dleq.s),r:we(s.dleq.r??"00")};if(!ge(s.amount,e.keys))throw new Error(`undefined key for amount ${s.amount}`);const n=e.keys[s.amount];return!!Me.verifyDLEQProof_reblind(new TextEncoder().encode(s.secret),t,x.pointFromHex(s.C),x.pointFromHex(n))}function ct(...s){const e=s.reduce((r,o)=>r+o.length,0),t=new Uint8Array(e);let n=0;for(let r=0;r<s.length;r++)t.set(s[r],n),n=n+s[r].length;return t}function at(s){const e=new TextEncoder,t=_e(s),n=J(t),r=e.encode("craw"),o=e.encode("B");return ct(r,o,n)}function ut(s){const e=new TextDecoder,t=e.decode(s.slice(0,4)),n=e.decode(new Uint8Array([s[4]]));if(t!=="craw"||n!=="B")throw new Error("not a valid binary token");const r=s.slice(5),o=X(r);return Ee(o)}function ue(s){return s.reduce((e,t)=>e+t,0)}let Z;typeof WebSocket<"u"&&(Z=WebSocket);function ht(s){Z=s}function dt(){return Z}class F{constructor(){this.connectionMap=new Map}static getInstance(){return F.instace||(F.instace=new F),F.instace}getConnection(e){if(this.connectionMap.has(e))return this.connectionMap.get(e);const t=new lt(e);return this.connectionMap.set(e,t),t}}class lt{constructor(e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this._WS=dt(),this.url=new URL(e),this.messageQueue=new it}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((e,t)=>{try{this.ws=new this._WS(this.url)}catch(n){t(n);return}this.ws.onopen=()=>{e()},this.ws.onerror=()=>{t(new Error("Failed to open WebSocket"))},this.ws.onmessage=n=>{this.messageQueue.enqueue(n.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMesage.bind(this),0))},this.ws.onclose=()=>{this.connectionPromise=void 0}})),this.connectionPromise}sendRequest(e,t){if(this.ws?.readyState!==1)throw new Error("Socket not open...");const n=this.rpcId;this.rpcId++;const r=JSON.stringify({jsonrpc:"2.0",method:e,params:t,id:n});this.ws?.send(r)}closeSubscription(e){this.ws?.send(JSON.stringify(["CLOSE",e]))}addSubListener(e,t){(this.subListeners[e]=this.subListeners[e]||[]).push(t)}addRpcListener(e,t,n){this.rpcListeners[n]={callback:e,errorCallback:t}}removeRpcListener(e){delete this.rpcListeners[e]}removeListener(e,t){if(this.subListeners[e].length===1){delete this.subListeners[e];return}this.subListeners[e]=this.subListeners[e].filter(n=>n!==t)}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMesage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const e=this.messageQueue.dequeue();let t;try{if(t=JSON.parse(e),"result"in t&&t.id!=null)this.rpcListeners[t.id]&&(this.rpcListeners[t.id].callback(),this.removeRpcListener(t.id));else if("error"in t&&t.id!=null)this.rpcListeners[t.id]&&(this.rpcListeners[t.id].errorCallback(t.error),this.removeRpcListener(t.id));else if("method"in t&&!("id"in t)){const n=t.params.subId;if(!n)return;if(this.subListeners[n]?.length>0){const r=t;this.subListeners[n].forEach(o=>o(r.params.payload))}}}catch(n){console.error(n);return}}createSubscription(e,t,n){if(this.ws?.readyState!==1)return n(new Error("Socket is not open"));const r=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(r,t)},o=>{n(new Error(o.message))},this.rpcId),this.sendRequest("subscribe",{...e,subId:r}),this.rpcId++,r}cancelSubscription(e,t){this.removeListener(e,t),this.rpcId++,this.sendRequest("unsubscribe",{subId:e})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}}var qe=(s=>(s.UNSPENT="UNSPENT",s.PENDING="PENDING",s.SPENT="SPENT",s))(qe||{}),O=(s=>(s.UNPAID="UNPAID",s.PENDING="PENDING",s.PAID="PAID",s))(O||{}),Q=(s=>(s.UNPAID="UNPAID",s.PAID="PAID",s.ISSUED="ISSUED",s))(Q||{}),Ie=(s=>(s.POST="post",s.NOSTR="nostr",s))(Ie||{});class N extends Error{constructor(e,t){super(e),this.status=t,this.name="HttpResponseError",Object.setPrototypeOf(this,N.prototype)}}class C extends Error{constructor(e){super(e),this.name="NetworkError",Object.setPrototypeOf(this,C.prototype)}}class z extends N{constructor(e,t){super(t||"Unknown mint operation error",400),this.code=e,this.name="MintOperationError",Object.setPrototypeOf(this,z.prototype)}}let Te={};function ft(s){Te=s}async function pt({endpoint:s,requestBody:e,headers:t,...n}){const r=e?JSON.stringify(e):void 0,o={Accept:"application/json, text/plain, */*",...r?{"Content-Type":"application/json"}:void 0,...t};let i;try{i=await fetch(s,{body:r,headers:o,...n})}catch(c){throw new C(c instanceof Error?c.message:"Network request failed")}if(!i.ok){const c=await i.json().catch(()=>({error:"bad response"}));throw i.status===400&&"code"in c&&"detail"in c?new z(c.code,c.detail):new N("error"in c?c.error:c.detail||"HTTP request failed",i.status)}try{return await i.json()}catch(c){throw console.error("Failed to parse HTTP response",c),new N("bad response",i.status)}}async function T(s){return await pt({...s,...Te})}function $(s){return s.state||(console.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof s.paid=="boolean"&&(s.state=s.paid?O.PAID:O.UNPAID)),s}function he(s){return s.state||(console.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof s.paid=="boolean"&&(s.state=s.paid?Q.PAID:Q.UNPAID)),s}function mt(s){return Array.isArray(s?.contact)&&s?.contact.length>0&&(s.contact=s.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(console.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),s}class _{constructor(e,t){this._mintUrl=e,this._customRequest=t,this._mintUrl=nt(e),this._customRequest=t}get mintUrl(){return this._mintUrl}static async getInfo(e,t){const r=await(t||T)({endpoint:S(e,"/v1/info")});return mt(r)}async getInfo(){return _.getInfo(this._mintUrl,this._customRequest)}static async swap(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/swap"),method:"POST",requestBody:t});if(!v(o)||!Array.isArray(o?.signatures))throw new Error(o.detail??"bad response");return o}async swap(e){return _.swap(this._mintUrl,e,this._customRequest)}static async createMintQuote(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/mint/quote/bolt11"),method:"POST",requestBody:t});return he(o)}async createMintQuote(e){return _.createMintQuote(this._mintUrl,e,this._customRequest)}static async checkMintQuote(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/mint/quote/bolt11",t),method:"GET"});return he(o)}async checkMintQuote(e){return _.checkMintQuote(this._mintUrl,e,this._customRequest)}static async mint(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/mint/bolt11"),method:"POST",requestBody:t});if(!v(o)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async mint(e){return _.mint(this._mintUrl,e,this._customRequest)}static async createMeltQuote(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/melt/quote/bolt11"),method:"POST",requestBody:t}),i=$(o);if(!v(i)||typeof i?.amount!="number"||typeof i?.fee_reserve!="number"||typeof i?.quote!="string")throw new Error("bad response");return i}async createMeltQuote(e){return _.createMeltQuote(this._mintUrl,e,this._customRequest)}static async checkMeltQuote(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/melt/quote/bolt11",t),method:"GET"}),i=$(o);if(!v(i)||typeof i?.amount!="number"||typeof i?.fee_reserve!="number"||typeof i?.quote!="string"||typeof i?.state!="string"||!Object.values(O).includes(i.state))throw new Error("bad response");return i}async checkMeltQuote(e){return _.checkMeltQuote(this._mintUrl,e,this._customRequest)}static async melt(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/melt/bolt11"),method:"POST",requestBody:t}),i=$(o);if(!v(i)||typeof i?.state!="string"||!Object.values(O).includes(i.state))throw new Error("bad response");return i}async melt(e){return _.melt(this._mintUrl,e,this._customRequest)}static async check(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/checkstate"),method:"POST",requestBody:t});if(!v(o)||!Array.isArray(o?.states))throw new Error("bad response");return o}static async getKeys(e,t,n){t&&(t=t.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(n||T)({endpoint:t?S(e,"/v1/keys",t):S(e,"/v1/keys")});if(!v(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(e,t){return await _.getKeys(t||this._mintUrl,e,this._customRequest)}static async getKeySets(e,t){return(t||T)({endpoint:S(e,"/v1/keysets")})}async getKeySets(){return _.getKeySets(this._mintUrl,this._customRequest)}async check(e){return _.check(this._mintUrl,e,this._customRequest)}static async restore(e,t,n){const o=await(n||T)({endpoint:S(e,"/v1/restore"),method:"POST",requestBody:t});if(!v(o)||!Array.isArray(o?.outputs)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async restore(e){return _.restore(this._mintUrl,e,this._customRequest)}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const e=new URL(this._mintUrl),t="v1/ws";e.pathname&&(e.pathname.endsWith("/")?e.pathname+=t:e.pathname+="/"+t),this.ws=F.getInstance().getConnection(`${e.protocol==="https:"?"wss":"ws"}://${e.host}${e.pathname}`);try{await this.ws.connect()}catch(n){throw console.log(n),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}}class de{constructor(e){this._mintInfo=e}isSupported(e){switch(e){case 4:case 5:return this.checkMintMelt(e);case 7:case 8:case 9:case 10:case 11:case 12:case 14:case 20:return this.checkGenericNut(e);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}checkGenericNut(e){return this._mintInfo.nuts[e]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(e){const t=this._mintInfo.nuts[e];return t&&t.methods.length>0&&!t.disabled?{disabled:!1,params:t.methods}:{disabled:!0,params:t.methods}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}}function yt(s,e){let t=s;for(const r of e)t+=r.B_;const n=new TextEncoder().encode(t);return le.sha256(n)}function gt(s,e,t){const n=yt(e,t),r=A.hexToBytes(s),o=ve.schnorr.sign(n,r);return A.bytesToHex(o)}class V{constructor(e,t,n){this.amount=e,this.B_=t,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}function G(s){return typeof s=="function"}class M{constructor(e,t,n){this.secret=n,this.blindingFactor=t,this.blindedMessage=e}toProof(e,t){let n;e.dleq&&(n={s:A.hexToBytes(e.dleq.s),e:A.hexToBytes(e.dleq.e),r:this.blindingFactor});const r={id:e.id,amount:e.amount,C_:x.pointFromHex(e.C_),dleq:n},o=x.pointFromHex(t.keys[e.amount]),i=B.constructProofFromPromise(r,this.blindingFactor,this.secret,o);return{...B.serializeProof(i),...n&&{dleq:{s:A.bytesToHex(n.s),e:A.bytesToHex(n.e),r:Ye(n.r??BigInt(0))}}}}static createP2PKData(e,t,n,r){return q(t,n.keys,r).map(i=>this.createSingleP2PKData(e,i,n.id))}static createSingleP2PKData(e,t,n){const r=["P2PK",{nonce:A.bytesToHex(A.randomBytes(32)),data:e.pubkey,tags:[]}];e.locktime&&r[1].tags.push(["locktime",e.locktime]),e.refundKeys&&r[1].tags.push(["refund",e.refundKeys]);const o=JSON.stringify(r),i=new TextEncoder().encode(o),{r:c,B_:a}=B.blindMessage(i);return new M(new V(t,a,n).getSerializedBlindedMessage(),c,i)}static createRandomData(e,t,n){return q(e,t.keys,n).map(o=>this.createSingleRandomData(o,t.id))}static createSingleRandomData(e,t){const n=A.bytesToHex(A.randomBytes(32)),r=new TextEncoder().encode(n),{r:o,B_:i}=B.blindMessage(r);return new M(new V(e,i,t).getSerializedBlindedMessage(),o,r)}static createDeterministicData(e,t,n,r,o){return q(e,r.keys,o).map((c,a)=>this.createSingleDeterministicData(c,t,n+a,r.id))}static createSingleDeterministicData(e,t,n,r){const o=ie.deriveSecret(t,r,n),i=A.bytesToHex(o),c=new TextEncoder().encode(i),a=Je(ie.deriveBlindingFactor(t,r,n)),{r:h,B_:d}=B.blindMessage(c,a);return new M(new V(e,d,r).getSerializedBlindedMessage(),h,c)}}const wt=3,kt="sat";class bt{constructor(e,t){this._keys=new Map,this._keysets=[],this._seed=void 0,this._unit=kt,this._mintInfo=void 0,this._denominationTarget=wt,this.mint=e;let n=[];if(t?.keys&&!Array.isArray(t.keys)?n=[t.keys]:t?.keys&&Array.isArray(t?.keys)&&(n=t?.keys),n&&n.forEach(r=>this._keys.set(r.id,r)),t?.unit&&(this._unit=t?.unit),t?.keysets&&(this._keysets=t.keysets),t?.mintInfo&&(this._mintInfo=new de(t.mintInfo)),t?.denominationTarget&&(this._denominationTarget=t.denominationTarget),t?.bip39seed){if(t.bip39seed instanceof Uint8Array){this._seed=t.bip39seed;return}throw new Error("bip39seed must be a valid UInt8Array")}t?.keepFactory&&(this._keepFactory=t.keepFactory)}get unit(){return this._unit}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(e){this._keysetId=e}get keysets(){return this._keysets}get mintInfo(){if(!this._mintInfo)throw new Error("Mint info not loaded");return this._mintInfo}async getMintInfo(){const e=await this.mint.getInfo();return this._mintInfo=new de(e),this._mintInfo}async lazyGetMintInfo(){return this._mintInfo?this._mintInfo:await this.getMintInfo()}async loadMint(){await this.getMintInfo(),await this.getKeySets(),await this.getKeys()}getActiveKeyset(e){let t=e.filter(r=>r.active);t=t.filter(r=>r.id.startsWith("00"));const n=t.sort((r,o)=>(r.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!n)throw new Error("No active keyset found");return n}async getKeySets(){const t=(await this.mint.getKeySets()).keysets.filter(n=>n.unit===this._unit);return this._keysets=t,this._keysets}async getAllKeys(){const e=await this.mint.getKeys();return this._keys=new Map(e.keysets.map(t=>[t.id,t])),this.keysetId=this.getActiveKeyset(this._keysets).id,e.keysets}async getKeys(e,t){if((!(this._keysets.length>0)||t)&&await this.getKeySets(),e||(e=this.getActiveKeyset(this._keysets).id),!this._keysets.find(n=>n.id===e)&&(await this.getKeySets(),!this._keysets.find(n=>n.id===e)))throw new Error(`could not initialize keys. No keyset with id '${e}' found`);if(!this._keys.get(e)){const n=await this.mint.getKeys(e);this._keys.set(e,n.keysets[0])}return this.keysetId=e,this._keys.get(e)}async receive(e,t){const{requireDleq:n,keysetId:r,outputAmounts:o,counter:i,pubkey:c,privkey:a,outputData:h,p2pk:d}=t||{};typeof e=="string"&&(e=Pe(e));const f=await this.getKeys(r);if(n&&e.proofs.some(k=>!Se(k,f)))throw new Error("Token contains proofs with invalid DLEQ");const m=U(e.proofs)-this.getFeesForProofs(e.proofs);let u;h?u={send:h}:this._keepFactory&&(u={send:this._keepFactory});const l=this.createSwapPayload(m,e.proofs,f,o,i,c,a,u,d),{signatures:w}=await this.mint.swap(l.payload),y=l.outputData.map((k,p)=>k.toProof(w[p],f)),g=[];return l.sortedIndices.forEach((k,p)=>{g[k]=y[p]}),g}async send(e,t,n){const{proofsWeHave:r,offline:o,includeFees:i,includeDleq:c,keysetId:a,outputAmounts:h,pubkey:d,privkey:f,outputData:m}=n||{};if(c&&(t=t.filter(y=>y.dleq!=null)),U(t)<e)throw new Error("Not enough funds available to send");const{keep:u,send:l}=this.selectProofsToSend(t,e,n?.includeFees),w=i?this.getFeesForProofs(l):0;if(!o&&(U(l)!=e+w||h||d||f||a||m)){const{keep:y,send:g}=this.selectProofsToSend(t,e,!0);r?.push(...y);const k=await this.swap(e,g,n);let{keep:p,send:P}=k;const D=k.serialized;return p=y.concat(p),c||(P=W(P)),{keep:p,send:P,serialized:D}}if(U(l)<e+w)throw new Error("Not enough funds available to send");return c?{keep:u,send:l}:{keep:u,send:W(l)}}selectProofsToSend(e,t,n){const r=e.sort((u,l)=>u.amount-l.amount),o=r.filter(u=>u.amount<=t).sort((u,l)=>l.amount-u.amount),c=r.filter(u=>u.amount>t).sort((u,l)=>u.amount-l.amount)[0];if(!o.length&&c)return{keep:e.filter(u=>u.secret!==c.secret),send:[c]};if(!o.length&&!c)return{keep:e,send:[]};let a=t,h=[o[0]];const d=[],f=n?this.getFeesForProofs(h):0;if(a-=h[0].amount-f/1e3,a>0){const{keep:u,send:l}=this.selectProofsToSend(o.slice(1),a,n);h.push(...l),d.push(...u)}const m=n?this.getFeesForProofs(h):0;return U(h)<t+m&&c&&(h=[c]),{keep:e.filter(u=>!h.includes(u)),send:h}}getFeesForProofs(e){if(!this._keysets.length)throw new Error("Could not calculate fees. No keysets found");return new Set(e.map(r=>r.id)).forEach(r=>{if(!this._keysets.find(o=>o.id===r))throw new Error(`Could not calculate fees. No keyset found with id: ${r}`)}),Math.floor(Math.max((e.reduce((r,o)=>r+(this._keysets.find(i=>i.id===o.id)?.input_fee_ppk||0),0)+999)/1e3,0))}getFeesForKeyset(e,t){return Math.floor(Math.max((e*(this._keysets.find(r=>r.id===t)?.input_fee_ppk||0)+999)/1e3,0))}async swap(e,t,n){let{outputAmounts:r}=n||{};const{includeFees:o,keysetId:i,counter:c,pubkey:a,privkey:h,proofsWeHave:d,outputData:f,p2pk:m}=n||{},u=await this.getKeys(i),l=t;let w=e;const y=U(t);let g=y-w-this.getFeesForProofs(l),k=r?.sendAmounts||q(w,u.keys);if(o){let b=this.getFeesForKeyset(k.length,u.id),I=q(b,u.keys);for(;this.getFeesForKeyset(k.concat(I).length,u.id)>b;)b++,I=q(b,u.keys);k=k.concat(I),w+=b,g-=b}let p;if(!r?.keepAmounts&&d)p=ce(d,g,u.keys,this._denominationTarget);else if(r){if(r.keepAmounts?.reduce((b,I)=>b+I,0)!=g)throw new Error("Keep amounts do not match amount to keep");p=r.keepAmounts}if(w+this.getFeesForProofs(l)>y)throw console.error(`Not enough funds available (${y}) for swap amountToSend: ${w} + fee: ${this.getFeesForProofs(l)} | length: ${l.length}`),new Error("Not enough funds available for swap");if(w+this.getFeesForProofs(l)+g!=y)throw new Error("Amounts do not match for swap");r={keepAmounts:p,sendAmounts:k};const P=f?.keep||this._keepFactory,D=f?.send,R=this.createSwapPayload(w,l,u,r,c,a,h,{keep:P,send:D},m),{signatures:Ae}=await this.mint.swap(R.payload),ee=R.outputData.map((b,I)=>b.toProof(Ae[I],u)),te=[],se=[],ne=Array(R.keepVector.length),re=Array(ee.length);return R.sortedIndices.forEach((b,I)=>{ne[b]=R.keepVector[I],re[b]=ee[I]}),re.forEach((b,I)=>{ne[I]?te.push(b):se.push(b)}),{keep:te,send:se}}async batchRestore(e=300,t=100,n=0,r){const o=Math.ceil(e/t),i=[];let c,a=0;for(;a<o;){const h=await this.restore(n,t,{keysetId:r});h.proofs.length>0?(a=0,i.push(...h.proofs),c=h.lastCounterWithSignature):a++,n+=t}return{proofs:i,lastCounterWithSignature:c}}async restore(e,t,n){const{keysetId:r}=n||{},o=await this.getKeys(r);if(!this._seed)throw new Error("CashuWallet must be initialized with a seed to use restore");const i=Array(t).fill(1),c=M.createDeterministicData(i.length,this._seed,e,o,i),{outputs:a,signatures:h}=await this.mint.restore({outputs:c.map(u=>u.blindedMessage)}),d={};a.forEach((u,l)=>d[u.B_]=h[l]);const f=[];let m;for(let u=0;u<c.length;u++){const l=d[c[u].blindedMessage.B_];l&&(m=e+u,c[u].blindedMessage.amount=l.amount,f.push(c[u].toProof(l,o)))}return{proofs:f,lastCounterWithSignature:m}}async createMintQuote(e,t){const n={unit:this._unit,amount:e,description:t};return await this.mint.createMintQuote(n)}async createLockedMintQuote(e,t,n){const{supported:r}=(await this.getMintInfo()).isSupported(20);if(!r)throw new Error("Mint does not support NUT-20");const o={unit:this._unit,amount:e,description:n,pubkey:t},i=await this.mint.createMintQuote(o);if(!i.pubkey)throw new Error("Mint returned unlocked mint quote");return i}async checkMintQuote(e){return await this.mint.checkMintQuote(e)}async mintProofs(e,t,n){let{outputAmounts:r}=n||{};const{counter:o,pubkey:i,p2pk:c,keysetId:a,proofsWeHave:h,outputData:d,privateKey:f}=n||{},m=await this.getKeys(a);!r&&h&&(r={keepAmounts:ce(h,e,m.keys,this._denominationTarget),sendAmounts:[]});let u=[];if(d)if(G(d)){const y=q(e,m.keys,r?.keepAmounts);for(let g=0;g<y.length;g++)u.push(d(y[g],m))}else u=d;else if(this._keepFactory){const y=q(e,m.keys,r?.keepAmounts);for(let g=0;g<y.length;g++)u.push(this._keepFactory(y[g],m))}else u=this.createOutputData(e,m,o,i,r?.keepAmounts,c);let l;if(typeof t!="string"){if(!f)throw new Error("Can not sign locked quote without private key");const y=u.map(k=>k.blindedMessage),g=gt(f,t.quote,y);l={outputs:y,quote:t.quote,signature:g}}else l={outputs:u.map(y=>y.blindedMessage),quote:t};const{signatures:w}=await this.mint.mint(l);return u.map((y,g)=>y.toProof(w[g],m))}async createMeltQuote(e){const t={unit:this._unit,request:e};return await this.mint.createMeltQuote(t)}async createMultiPathMeltQuote(e,t){const{supported:n,params:r}=(await this.lazyGetMintInfo()).isSupported(15);if(!n)throw new Error("Mint does not support NUT-15");if(!r?.some(h=>h.method==="bolt11"&&h.unit===this.unit))throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);const i={mpp:{amount:t}},c={unit:this._unit,request:e,options:i};return await this.mint.createMeltQuote(c)}async checkMeltQuote(e){return await this.mint.checkMeltQuote(e)}async meltProofs(e,t,n){const{keysetId:r,counter:o,privkey:i}=n||{},c=await this.getKeys(r),a=this.createBlankOutputs(U(t)-e.amount,c,o,this._keepFactory);i!=null&&(t=oe.getSignedProofs(t.map(f=>({amount:f.amount,C:x.pointFromHex(f.C),id:f.id,secret:new TextEncoder().encode(f.secret)})),i).map(f=>B.serializeProof(f))),t=W(t);const h={quote:e.quote,inputs:t,outputs:a.map(f=>f.blindedMessage)},d=await this.mint.melt(h);return{quote:d,change:d.change?.map((f,m)=>a[m].toProof(f,c))??[]}}createSwapPayload(e,t,n,r,o,i,c,a,h){const d=t.reduce((p,P)=>p+P.amount,0);r&&r.sendAmounts&&!r.keepAmounts&&(r.keepAmounts=q(d-e-this.getFeesForProofs(t),n.keys));const f=d-e-this.getFeesForProofs(t);let m=[],u=[];if(a?.keep)if(G(a.keep)){const p=a.keep;q(f,n.keys).forEach(D=>{m.push(p(D,n))})}else m=a.keep;else m=this.createOutputData(f,n,o,void 0,r?.keepAmounts,void 0,this._keepFactory);if(a?.send)if(G(a.send)){const p=a.send;q(e,n.keys).forEach(D=>{u.push(p(D,n))})}else u=a.send;else u=this.createOutputData(e,n,o?o+m.length:void 0,i,r?.sendAmounts,h);c&&(t=oe.getSignedProofs(t.map(p=>({amount:p.amount,C:x.pointFromHex(p.C),id:p.id,secret:new TextEncoder().encode(p.secret)})),c).map(p=>B.serializeProof(p))),t=W(t);const l=[...m,...u],w=l.map((p,P)=>P).sort((p,P)=>l[p].blindedMessage.amount-l[P].blindedMessage.amount),y=[...Array(m.length).fill(!0),...Array(u.length).fill(!1)],g=w.map(p=>l[p]),k=w.map(p=>y[p]);return{payload:{inputs:t,outputs:g.map(p=>p.blindedMessage)},outputData:g,keepVector:k,sortedIndices:w}}async checkProofsStates(e){const t=new TextEncoder,n=e.map(i=>x.hashToCurve(t.encode(i.secret)).toHex(!0)),r=100,o=[];for(let i=0;i<n.length;i+=r){const c=n.slice(i,i+r),{states:a}=await this.mint.check({Ys:c}),h={};a.forEach(d=>{h[d.Y]=d});for(let d=0;d<c.length;d++){const f=h[c[d]];if(!f)throw new Error("Could not find state for proof with Y: "+c[d]);o.push(f)}}return o}async onMintQuoteUpdates(e,t,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_mint_quote",filters:e},t,n);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,t)}}async onMeltQuotePaid(e,t,n){return this.onMeltQuoteUpdates([e],r=>{r.state===O.PAID&&t(r)},n)}async onMintQuotePaid(e,t,n){return this.onMintQuoteUpdates([e],r=>{r.state===Q.PAID&&t(r)},n)}async onMeltQuoteUpdates(e,t,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_melt_quote",filters:e},t,n);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,t)}}async onProofStateUpdates(e,t,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=new TextEncoder,o={};for(let a=0;a<e.length;a++){const h=x.hashToCurve(r.encode(e[a].secret)).toHex(!0);o[h]=e[a]}const i=Object.keys(o),c=this.mint.webSocketConnection.createSubscription({kind:"proof_state",filters:i},a=>{t({...a,proof:o[a.Y]})},n);return()=>{this.mint.webSocketConnection?.cancelSubscription(c,t)}}createOutputData(e,t,n,r,o,i,c){let a;if(r)a=M.createP2PKData({pubkey:r},e,t,o);else if(n||n===0){if(!this._seed)throw new Error("cannot create deterministic messages without seed");a=M.createDeterministicData(e,this._seed,n,t,o)}else i?a=M.createP2PKData(i,e,t,o):c?a=q(e,t.keys).map(d=>c(d,t)):a=M.createRandomData(e,t,o);return a}createBlankOutputs(e,t,n,r){let o=Math.ceil(Math.log2(e))||1;o<0&&(o=0);const i=o?Array(o).fill(1):[];return this.createOutputData(e,t,n,void 0,i,void 0,r)}}exports.CashuMint=_;exports.CashuWallet=bt;exports.CheckStateEnum=qe;exports.HttpResponseError=N;exports.MeltQuoteState=O;exports.MintOperationError=z;exports.MintQuoteState=Q;exports.NetworkError=C;exports.OutputData=M;exports.PaymentRequest=j;exports.PaymentRequestTransportType=Ie;exports.decodePaymentRequest=rt;exports.deriveKeysetId=tt;exports.getDecodedToken=Pe;exports.getDecodedTokenBinary=ut;exports.getEncodedToken=Ze;exports.getEncodedTokenBinary=at;exports.getEncodedTokenV4=be;exports.hasValidDleq=Se;exports.injectWebSocketImpl=ht;exports.setGlobalRequestOptions=ft;
//# sourceMappingURL=cashu-ts.cjs.js.map
